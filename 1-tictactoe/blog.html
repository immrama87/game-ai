<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/>

    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://raw.githubusercontent.com/immrama87/game-ai/gh-pages/node_modules/github-markdown-css/github-markdown.css"/>

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

    <title>Learning By Doing: Tic Tac Toe</title>
  </head>
  <body>
    <header class="navbar navbar-default justify-content-center">
      <a class="navbar-brand display-1"><h1>Learning By Doing: Tic Tac Toe</h1></a>
    </header>
    <div class="container">
      <h1>
<a id="user-content-learning-by-doing-game-ai" class="anchor" href="#learning-by-doing-game-ai" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Learning by Doing: Game AI</h1>
<h2>
<a id="user-content-tic-tac-toe" class="anchor" href="#tic-tac-toe" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Tic Tac Toe</h2>
<h3>
<a id="user-content-introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h3>
<p>AI development is a complicated but fascinating process. A simple game like Tic Tac Toe is a perfect starting point because the ruleset is extremely basic and the results of any processing can be immediately visualized, giving us the opportunity to quickly evaluate how successful or unsuccessful our AI is. Finally, as the movie <em>War Games</em> showed, Tic Tac Toe is a game in which two players who are consistently making the optimal move will always end in stalemate, giving us a clearly defined goal for the final state of our AI.</p>
<h3>
<a id="user-content-part-1-initial-setup" class="anchor" href="#part-1-initial-setup" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Part 1: Initial Setup</h3>
<p>Before we can start working on AI, we need to have at least a minimally working Tic Tac Toe game. The requirements for this are:</p>
<ul>
<li>A renderer which is capable of consuming or tracking a game state and generating the visual representation of the game board.</li>
<li>A simple CLI that collects row and column inputs and outputs the rendered game board and any system messages.</li>
<li>Input validation to ensure that column and row input are both numeric and within the correct bounds.</li>
<li>A game loop which tracks which of the two players is currently playing.</li>
</ul>
<p>To start our project folder should contain just an index.js file and (optionally) package.json file.</p>
<h4>
<a id="user-content-the-game-board" class="anchor" href="#the-game-board" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Game Board</h4>
<p>Generating our gameboard is fairly straightforward, we just need something that outputs 3 columns and 3 rows, each with 3 possible states (neutral, player 1 and player 2). In our index.js file, we can do this with:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> state <span class="pl-k">=</span> [<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>]; <span class="pl-c"><span class="pl-c">//</span>Pre-initialize a state array with 9 elements</span>
<span class="pl-k">const</span> <span class="pl-c1">stateTokens</span> <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>O<span class="pl-pds">'</span></span>]; <span class="pl-c"><span class="pl-c">//</span>State tokens to display the state of a game board cell</span>

<span class="pl-k">function</span> <span class="pl-en">render</span>(){
  <span class="pl-k">var</span> gameboard <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;

  <span class="pl-k">var</span> i, separator;
  <span class="pl-k">for</span>(i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">state</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
    separator <span class="pl-k">=</span> ((i <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">?</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>|<span class="pl-pds">'</span></span>;
    gameboard <span class="pl-k">+=</span> stateTokens[state[i]] <span class="pl-k">+</span> separator;
  }
  <span class="pl-en">console</span>.<span class="pl-c1">log</span>(gameboard);
}

<span class="pl-en">render</span>();</pre></div>
<p>Running <code>node index</code> now will give us output that should look like</p>
<p><a href="https://raw.githubusercontent.com/immrama87/game-ai/master/1-tictactoe/images/Screen%20Shot%202019-10-23%20at%203.23.20%20PM.png" target="_blank" rel="nofollow"><img src="https://raw.githubusercontent.com/immrama87/game-ai/master/1-tictactoe/images/Screen%20Shot%202019-10-23%20at%203.23.20%20PM.png" alt="Initial Game Rendering" style="max-width:100%;"></a></p>
<h4>
<a id="user-content-the-cli" class="anchor" href="#the-cli" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The CLI</h4>
<p>Now that we have a game board to play on, it's time to start collecting input from the player to play our Tic Tac Toe game. We're going to create a simple CLI, built around a readline interface that will simply write arbitrary string data and prompt the player for input.</p>
<p>We will first create a new directory in our project folder called "CLI" and inside this new directory create a file called index.js. The contents of this file should be:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-c1">CLI</span> <span class="pl-k">=</span> (<span class="pl-k">function</span>(<span class="pl-k">interface</span> <span class="pl-c"><span class="pl-c">/**</span> Readline.Interface *<span class="pl-c">*/</span></span>){
  <span class="pl-k">var</span> cli <span class="pl-k">=</span> {};
  <span class="pl-smi">cli</span>.<span class="pl-en">write</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">str</span>){
    <span class="pl-k">interface</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> str <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
  };

  <span class="pl-smi">cli</span>.<span class="pl-en">prompt</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">question</span>){
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>(<span class="pl-k">function</span>(<span class="pl-smi">resolve</span>, <span class="pl-smi">reject</span>){
      <span class="pl-k">interface</span>.<span class="pl-en">question</span>(question, <span class="pl-k">function</span>(<span class="pl-smi">answer</span>){
        <span class="pl-en">resolve</span>(answer);
      });
    });
  };

  <span class="pl-k">return</span> cli;
});

<span class="pl-c1">module</span>.<span class="pl-smi">exports</span> <span class="pl-k">=</span> <span class="pl-c1">CLI</span>;</pre></div>
<p>This new CLI class, and the <em>readline</em> library, will now need to be <strong>require</strong>d in our main /index.js file so that we can use it to collect our player inputs. At the top of the file we need to add:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">readline</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>readline<span class="pl-pds">'</span></span>);
<span class="pl-k">const</span> <span class="pl-c1">cli</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./CLI<span class="pl-pds">'</span></span>)(<span class="pl-smi">readline</span>.<span class="pl-en">createInterface</span>({
  input<span class="pl-k">:</span> <span class="pl-c1">process</span>.<span class="pl-smi">stdin</span>,
  output<span class="pl-k">:</span> <span class="pl-c1">process</span>.<span class="pl-smi">stdout</span>
}));
</pre></div>
<p>and we'll need to add the following functions to collect our inputs:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">promptForColumn</span>(){
  <span class="pl-smi">cli</span>.<span class="pl-c1">prompt</span>(<span class="pl-s"><span class="pl-pds">"</span>Enter a column: <span class="pl-pds">"</span></span>)
    .<span class="pl-c1">then</span>(<span class="pl-k">function</span> <span class="pl-en">resolved</span>(<span class="pl-smi">column</span>){
      <span class="pl-en">promptForRow</span>(column);
    });
}

<span class="pl-k">function</span> <span class="pl-en">promptForRow</span>(<span class="pl-smi">column</span>){
  <span class="pl-smi">cli</span>.<span class="pl-c1">prompt</span>(<span class="pl-s"><span class="pl-pds">"</span>Enter a row: <span class="pl-pds">"</span></span>)
    .<span class="pl-c1">then</span>(<span class="pl-k">function</span> <span class="pl-en">resolved</span>(<span class="pl-smi">row</span>){
      <span class="pl-k">var</span> cell <span class="pl-k">=</span> ((row <span class="pl-k">-</span> <span class="pl-c1">1</span>) <span class="pl-k">*</span> <span class="pl-c1">3</span>) <span class="pl-k">+</span> (column <span class="pl-k">-</span> <span class="pl-c1">1</span>);
      state[cell] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
      <span class="pl-en">render</span>();
    });
}</pre></div>
<p>Finally, we'll replace the call to the <strong>render</strong> function with a call to the new <strong>promptForColumn</strong> function and the complete /index.js file should look like:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">readline</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>readline<span class="pl-pds">'</span></span>);
<span class="pl-k">const</span> <span class="pl-c1">cli</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./CLI<span class="pl-pds">'</span></span>)(<span class="pl-smi">readline</span>.<span class="pl-en">createInterface</span>({
  input<span class="pl-k">:</span> <span class="pl-c1">process</span>.<span class="pl-smi">stdin</span>,
  output<span class="pl-k">:</span> <span class="pl-c1">process</span>.<span class="pl-smi">stdout</span>
}));

<span class="pl-k">var</span> state <span class="pl-k">=</span> [<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>]; <span class="pl-c"><span class="pl-c">//</span>Pre-initialize a state array with 9 elements</span>
<span class="pl-k">const</span> <span class="pl-c1">stateTokens</span> <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>O<span class="pl-pds">'</span></span>]; <span class="pl-c"><span class="pl-c">//</span>State tokens to display the state of a game board cell</span>

<span class="pl-k">function</span> <span class="pl-en">render</span>(){
  <span class="pl-k">var</span> gameboard <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;

  <span class="pl-k">var</span> i, separator;
  <span class="pl-k">for</span>(i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">state</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
    separator <span class="pl-k">=</span> ((i <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">?</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>|<span class="pl-pds">'</span></span>;
    gameboard <span class="pl-k">+=</span> stateTokens[state[i]] <span class="pl-k">+</span> separator;
  }
  <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(gameboard);
}

<span class="pl-k">function</span> <span class="pl-en">promptForColumn</span>(){
  <span class="pl-smi">cli</span>.<span class="pl-c1">prompt</span>(<span class="pl-s"><span class="pl-pds">"</span>Enter a column: <span class="pl-pds">"</span></span>)
    .<span class="pl-c1">then</span>(<span class="pl-k">function</span> <span class="pl-en">resolved</span>(<span class="pl-smi">column</span>){
      <span class="pl-en">promptForRow</span>(column);
    });
}

<span class="pl-k">function</span> <span class="pl-en">promptForRow</span>(<span class="pl-smi">column</span>){
  <span class="pl-smi">cli</span>.<span class="pl-c1">prompt</span>(<span class="pl-s"><span class="pl-pds">"</span>Enter a row: <span class="pl-pds">"</span></span>)
    .<span class="pl-c1">then</span>(<span class="pl-k">function</span> <span class="pl-en">resolved</span>(<span class="pl-smi">row</span>){
      <span class="pl-k">var</span> cell <span class="pl-k">=</span> ((row <span class="pl-k">-</span> <span class="pl-c1">1</span>) <span class="pl-k">*</span> <span class="pl-c1">3</span>) <span class="pl-k">+</span> (column <span class="pl-k">-</span> <span class="pl-c1">1</span>);
      state[cell] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
      <span class="pl-en">render</span>();
    });
}

<span class="pl-en">promptForColumn</span>();</pre></div>
<p>Now, we have a game (sort of)! If we run <code>node index</code> now, we should see something like</p>
<p><a href="https://github.com/immrama87/game-ai/blob/master/1-tictactoe/images/Screen%20Shot%202019-10-23%20at%203.25.54%20PM.png?raw=true" target="_blank" rel="noopener noreferrer"><img src="https://github.com/immrama87/game-ai/raw/master/1-tictactoe/images/Screen%20Shot%202019-10-23%20at%203.25.54%20PM.png?raw=true" alt="First round with player input" style="max-width:100%;"></a></p>
<p>The game takes our inputs for a column and row and outputs an updated game board with an 'X' in the selected space, so we've got two of our four boxes checked. We still need input validation, because at this point the player can enter string data or overload the <strong>state</strong> array because we are simply trusting that their input is valid. The game also only works once, so it's currently impossible to win, lose or draw.</p>
<p>First, let's tackle the easier input validation problem, then we can wrap everything up in a game loop. We'll need to add the following to /index.js:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">validateInput</span>(<span class="pl-smi">str</span>){
  <span class="pl-k">var</span> num <span class="pl-k">=</span> <span class="pl-c1">parseInt</span>(str);
  <span class="pl-k">if</span>(<span class="pl-c1">isNaN</span>(num)){
    <span class="pl-k">return</span> <span class="pl-c1">false</span>; <span class="pl-c"><span class="pl-c">//</span>If the string is not parseable as an int, fail</span>
  }
  <span class="pl-k">if</span>(num <span class="pl-k">&lt;</span> <span class="pl-c1">1</span> <span class="pl-k">||</span> num <span class="pl-k">&gt;</span> <span class="pl-c1">3</span>){
    <span class="pl-k">return</span> <span class="pl-c1">false</span>; <span class="pl-c"><span class="pl-c">//</span>Makes sure the int is between 1 and 3</span>
  }

  <span class="pl-k">return</span> num <span class="pl-k">-</span> <span class="pl-c1">1</span>; <span class="pl-c"><span class="pl-c">//</span>0-index our number here</span>
}</pre></div>
<p>This function will serve 3 purposes. First, we make sure that the input is actually an integer, second we make sure that it fits within the bounds of the game board and finally we 0-index the result that we pass back so that the math later will look a little cleaner.</p>
<p>Now that we have the function, we'll need to update the <strong>promptForColumn</strong> and <strong>promptForRow</strong> functions to validate input before continuing, as such:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">promptForColumn</span>(){
  <span class="pl-smi">cli</span>.<span class="pl-c1">prompt</span>(<span class="pl-s"><span class="pl-pds">"</span>Enter a column: <span class="pl-pds">"</span></span>)
    .<span class="pl-c1">then</span>(<span class="pl-k">function</span> <span class="pl-en">resolved</span>(<span class="pl-smi">column</span>){
      column <span class="pl-k">=</span> <span class="pl-en">validateInput</span>(column);
      <span class="pl-k">if</span>(column <span class="pl-k">===</span> <span class="pl-c1">false</span>){
        <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>Column input must be a valid number between 1 and 3.<span class="pl-pds">"</span></span>);
        <span class="pl-en">promptForColumn</span>();
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
      }

      <span class="pl-en">promptForRow</span>(column);
    });
}

<span class="pl-k">function</span> <span class="pl-en">promptForRow</span>(<span class="pl-smi">column</span>){
  <span class="pl-smi">cli</span>.<span class="pl-c1">prompt</span>(<span class="pl-s"><span class="pl-pds">"</span>Enter a row: <span class="pl-pds">"</span></span>)
    .<span class="pl-c1">then</span>(<span class="pl-k">function</span> <span class="pl-en">resolved</span>(<span class="pl-smi">row</span>){
      row <span class="pl-k">=</span> <span class="pl-en">validateInput</span>(row);
      <span class="pl-k">if</span>(row <span class="pl-k">===</span> <span class="pl-c1">false</span>){
        <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>Row input must be a valid number between 1 and 3.<span class="pl-pds">"</span></span>);
        <span class="pl-en">promptForRow</span>(column);
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
      }

      <span class="pl-k">var</span> cell <span class="pl-k">=</span> (row <span class="pl-k">*</span> <span class="pl-c1">3</span>) <span class="pl-k">+</span> column;
      state[cell] <span class="pl-k">=</span> <span class="pl-c1">1</span>;
      <span class="pl-en">render</span>();
    });
}</pre></div>
<p>Now that we have the CLI working and we're validating our inputs, all that's left is to make it loop so that we can actually fill up the game board.</p>
<p>First, in the initial variable declarations, we need to add a variable to track which player is currently playing (otherwise we'll only have 'X's on the board). Let's call it currentPlayer and set it to 0 initially.</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> currentPlayer <span class="pl-k">=</span> <span class="pl-c1">0</span>;</pre></div>
<p>Now in the <strong>promptForRow</strong> function, instead of hardcoding the updated state for a cell to 1, let's use our new <em>currentPlayer</em> variable.</p>
<div class="highlight highlight-source-js"><pre>state[cell] <span class="pl-k">=</span> currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>;</pre></div>
<p>Finally, to get it all to loop, we'll add the following to the end of the <strong>render</strong> function:</p>
<div class="highlight highlight-source-js"><pre>currentPlayer <span class="pl-k">=</span> (currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">%</span> <span class="pl-c1">2</span>; <span class="pl-c"><span class="pl-c">//</span>Make sure we're clamping it so there are only 2 players.</span>
<span class="pl-en">promptForColumn</span>();</pre></div>
<p>Now, if we run <code>node index</code> we should see something like</p>
<p><a href="https://github.com/immrama87/game-ai/blob/master/1-tictactoe/images/Screen%20Shot%202019-10-23%20at%203.51.53%20PM.png?raw=true" target="_blank" rel="noopener noreferrer"><img src="https://github.com/immrama87/game-ai/raw/master/1-tictactoe/images/Screen%20Shot%202019-10-23%20at%203.51.53%20PM.png?raw=true" alt="Game loops and tracks player" style="max-width:100%;"></a></p>
<p>At this point our /index.js should look like:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">readline</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>readline<span class="pl-pds">'</span></span>);
<span class="pl-k">const</span> <span class="pl-c1">cli</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./CLI<span class="pl-pds">'</span></span>)(<span class="pl-smi">readline</span>.<span class="pl-en">createInterface</span>({
  input<span class="pl-k">:</span> <span class="pl-c1">process</span>.<span class="pl-smi">stdin</span>,
  output<span class="pl-k">:</span> <span class="pl-c1">process</span>.<span class="pl-smi">stdout</span>
}));

<span class="pl-k">var</span> state <span class="pl-k">=</span> [<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>]; <span class="pl-c"><span class="pl-c">//</span>Pre-initialize a state array with 9 elements</span>
<span class="pl-k">const</span> <span class="pl-c1">stateTokens</span> <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>O<span class="pl-pds">'</span></span>]; <span class="pl-c"><span class="pl-c">//</span>State tokens to display the state of a game board cell</span>
<span class="pl-k">var</span> currentPlayer <span class="pl-k">=</span> <span class="pl-c1">0</span>;

<span class="pl-k">function</span> <span class="pl-en">render</span>(){
  <span class="pl-k">var</span> gameboard <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;

  <span class="pl-k">var</span> i, separator;
  <span class="pl-k">for</span>(i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">state</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
    separator <span class="pl-k">=</span> ((i <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">?</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>|<span class="pl-pds">'</span></span>;
    gameboard <span class="pl-k">+=</span> stateTokens[state[i]] <span class="pl-k">+</span> separator;
  }
  <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(gameboard);

  currentPlayer <span class="pl-k">=</span> (currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">%</span> <span class="pl-c1">2</span>; <span class="pl-c"><span class="pl-c">//</span>Make sure we're clamping it so there are only 2 players.</span>
  <span class="pl-en">promptForColumn</span>();
}

<span class="pl-k">function</span> <span class="pl-en">validateInput</span>(<span class="pl-smi">str</span>){
  <span class="pl-k">var</span> num <span class="pl-k">=</span> <span class="pl-c1">parseInt</span>(str);
  <span class="pl-k">if</span>(<span class="pl-c1">isNaN</span>(num)){
    <span class="pl-k">return</span> <span class="pl-c1">false</span>; <span class="pl-c"><span class="pl-c">//</span>If the string is not parseable as an int, fail</span>
  }
  <span class="pl-k">if</span>(num <span class="pl-k">&lt;</span> <span class="pl-c1">1</span> <span class="pl-k">||</span> num <span class="pl-k">&gt;</span> <span class="pl-c1">3</span>){
    <span class="pl-k">return</span> <span class="pl-c1">false</span>; <span class="pl-c"><span class="pl-c">//</span>Makes sure the int is between 1 and 3</span>
  }

  <span class="pl-k">return</span> num <span class="pl-k">-</span> <span class="pl-c1">1</span>; <span class="pl-c"><span class="pl-c">//</span>0-index our number here</span>
}

<span class="pl-k">function</span> <span class="pl-en">promptForColumn</span>(){
  <span class="pl-smi">cli</span>.<span class="pl-c1">prompt</span>(<span class="pl-s"><span class="pl-pds">"</span>Enter a column: <span class="pl-pds">"</span></span>)
    .<span class="pl-c1">then</span>(<span class="pl-k">function</span> <span class="pl-en">resolved</span>(<span class="pl-smi">column</span>){
      column <span class="pl-k">=</span> <span class="pl-en">validateInput</span>(column);
      <span class="pl-k">if</span>(column <span class="pl-k">===</span> <span class="pl-c1">false</span>){
        <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>Column input must be a valid number between 1 and 3.<span class="pl-pds">"</span></span>);
        <span class="pl-en">promptForColumn</span>();
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
      }

      <span class="pl-en">promptForRow</span>(column);
    });
}

<span class="pl-k">function</span> <span class="pl-en">promptForRow</span>(<span class="pl-smi">column</span>){
  <span class="pl-smi">cli</span>.<span class="pl-c1">prompt</span>(<span class="pl-s"><span class="pl-pds">"</span>Enter a row: <span class="pl-pds">"</span></span>)
    .<span class="pl-c1">then</span>(<span class="pl-k">function</span> <span class="pl-en">resolved</span>(<span class="pl-smi">row</span>){
      row <span class="pl-k">=</span> <span class="pl-en">validateInput</span>(row);
      <span class="pl-k">if</span>(row <span class="pl-k">===</span> <span class="pl-c1">false</span>){
        <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>Row input must be a valid number between 1 and 3.<span class="pl-pds">"</span></span>);
        <span class="pl-en">promptForRow</span>(column);
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
      }

      <span class="pl-k">var</span> cell <span class="pl-k">=</span> (row <span class="pl-k">*</span> <span class="pl-c1">3</span>) <span class="pl-k">+</span> column;
      state[cell] <span class="pl-k">=</span> currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>;
      <span class="pl-en">render</span>();
    });
}

<span class="pl-en">promptForColumn</span>();</pre></div>
<p>and our /CLI/index.js should look like:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-c1">CLI</span> <span class="pl-k">=</span> (<span class="pl-k">function</span>(<span class="pl-k">interface</span> <span class="pl-c"><span class="pl-c">/**</span> Readline.Interface *<span class="pl-c">*/</span></span>){
  <span class="pl-k">var</span> cli <span class="pl-k">=</span> {};
  <span class="pl-smi">cli</span>.<span class="pl-en">write</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">str</span>){
    <span class="pl-k">interface</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> str <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
  };

  <span class="pl-smi">cli</span>.<span class="pl-en">prompt</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">question</span>){
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>(<span class="pl-k">function</span>(<span class="pl-smi">resolve</span>, <span class="pl-smi">reject</span>){
      <span class="pl-k">interface</span>.<span class="pl-en">question</span>(question, <span class="pl-k">function</span>(<span class="pl-smi">answer</span>){
        <span class="pl-en">resolve</span>(answer);
      });
    });
  };

  <span class="pl-k">return</span> cli;
});

<span class="pl-c1">module</span>.<span class="pl-smi">exports</span> <span class="pl-k">=</span> <span class="pl-c1">CLI</span>;</pre></div>
<h4>
<a id="user-content-game-states" class="anchor" href="#game-states" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Game States</h4>
<p>We're almost to the point where we can start programming some AI for our Tic Tac Toe game, but there's a couple of problems that still need to be dealt with. The biggest one is that there's no way to win or lose the game and there's no validation that tokens are only placed in empty cells. For the sake of keeping /index.js clean, as well as to help us out when we start building our AI, we're going to offload this functionality into a new GameState class. So let's start by creating a new GameState directory in our project folder and create an index.js file in this new directory, with the following contents:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> GameState <span class="pl-k">=</span> (<span class="pl-k">function</span>(<span class="pl-smi">state</span>){
  state <span class="pl-k">=</span> state <span class="pl-k">||</span> [<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>];

  <span class="pl-k">var</span> gs <span class="pl-k">=</span> {};

  <span class="pl-smi">gs</span>.<span class="pl-en">setCell</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cell</span>, <span class="pl-smi">player</span>){
    state[cell] <span class="pl-k">=</span> player;
  }

  <span class="pl-smi">gs</span>.<span class="pl-en">getState</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-k">return</span> state;
  }

  <span class="pl-k">return</span> gs;
});

<span class="pl-c1">module</span>.<span class="pl-smi">exports</span> <span class="pl-k">=</span> GameState;</pre></div>
<p>This new class doesn't actually provide us any new functionality yet, but it does give us what we already have in an external method call that we can more easily modify without turning /index.js into spaghetti.</p>
<p>Now, in /index.js, we'll need to <strong>require</strong> this new class, right below where we're <strong>require</strong>ing readline and CLI, and then replace the line</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> state <span class="pl-k">=</span> [<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>]; <span class="pl-c"><span class="pl-c">//</span>Pre-initialize a state array with 9 elements</span></pre></div>
<p>with</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">gameState</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">GameState</span>();</pre></div>
<p>And finally we'll need to modify the <strong>render</strong> and <strong>promptForRow</strong> functions to use the new GameState object instead of the hardcoded array, so at the beginning of the <strong>render</strong> function we'll add:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">getState</span>();</pre></div>
<p>and modify the line</p>
<div class="highlight highlight-source-js"><pre>state[cell] <span class="pl-k">=</span> currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>;</pre></div>
<p>in <strong>promptForRow</strong> to</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">gameState</span>.<span class="pl-en">setCell</span>(cell, currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>);</pre></div>
<p>and we're all set to start building some state checks into our game.</p>
<p>The easiest state check we can build is the stalemate check. All we're looking for here is a state in which all cells on the game board have a token placed, so we'll add a new function the GameState class, <strong>hasEmptyCells</strong>, which will perform this check:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">gs</span>.<span class="pl-en">hasEmptyCells</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
  <span class="pl-k">return</span> <span class="pl-smi">state</span>.<span class="pl-c1">indexOf</span>(<span class="pl-c1">0</span>) <span class="pl-k">&gt;</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
}</pre></div>
<p>Now, in the <strong>render</strong> function in /index.js we can use this new check to determine if we should be moving along to the next player or displaying a stalemate message, by making a modification to the lines</p>
<div class="highlight highlight-source-js"><pre>currentPlayer <span class="pl-k">=</span> (currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">%</span> <span class="pl-c1">2</span>; <span class="pl-c"><span class="pl-c">//</span>Make sure we're clamping it so there are only 2 players.</span>
<span class="pl-en">promptForColumn</span>();</pre></div>
<p>to read</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">if</span>(<span class="pl-smi">gameState</span>.<span class="pl-en">hasEmptyCells</span>()){
  currentPlayer <span class="pl-k">=</span> (currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">%</span> <span class="pl-c1">2</span>; <span class="pl-c"><span class="pl-c">//</span>Make sure we're clamping it so there are only 2 players.</span>
  <span class="pl-en">promptForColumn</span>();
}
<span class="pl-k">else</span> {
  <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>There are no remaining moves to play. Stalemate!!!<span class="pl-pds">"</span></span>);
  <span class="pl-c1">process</span>.<span class="pl-en">exit</span>();
}</pre></div>
<p>Testing this, we should end up with something that looks like this</p>
<p><a href="https://github.com/immrama87/game-ai/blob/master/1-tictactoe/images/Screen%20Shot%202019-10-23%20at%204.51.04%20PM.png?raw=true" target="_blank" rel="noopener noreferrer"><img src="https://github.com/immrama87/game-ai/raw/master/1-tictactoe/images/Screen%20Shot%202019-10-23%20at%204.51.04%20PM.png?raw=true" alt="Stalemate condition reached" style="max-width:100%;"></a></p>
<p>And now our game has its first end condition (even if it is the most boring one...)! We do still have the issue that players can overwrite their opponent's tokens, so before we build in a win condition, let's make sure players can't cheat first.</p>
<p>Currently, the GameState class is simply taking a cell and placing the requested token, but we need it to make sure that cell is empty first, which as we just saw is dead simple, so we just need to add a simple condition to the <strong>setCell</strong> method, to read:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">gs</span>.<span class="pl-en">setCell</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cell</span>, <span class="pl-smi">player</span>){
  <span class="pl-k">if</span>(state[cell] <span class="pl-k">==</span> <span class="pl-c1">0</span>){
    state[cell] <span class="pl-k">=</span> player;
    <span class="pl-k">return</span> <span class="pl-c1">true</span>;
  }
  <span class="pl-k">return</span> <span class="pl-c1">false</span>;
}</pre></div>
<p>This has now additionally given the <strong>setCell</strong> method a boolean return value that we can use in the game loop to determine if the placement of the token was successful, so in the <strong>promptForRow</strong> function, we'll replace the simple</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">gameState</span>.<span class="pl-en">setCell</span>(cell, currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>);
<span class="pl-en">render</span>();</pre></div>
<p>with</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">if</span>(<span class="pl-smi">gameState</span>.<span class="pl-en">setCell</span>(cell, currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>)){
  <span class="pl-en">render</span>();
}
<span class="pl-k">else</span> {
  <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>The selected cell has already been played on. A cell must be empty in order to be played.<span class="pl-pds">"</span></span>);
  <span class="pl-en">promptForColumn</span>();
}</pre></div>
<p>Running <code>node index</code> now and trying to play the same cell twice should end up prompting the error message above, like this</p>
<p><a href="https://github.com/immrama87/game-ai/blob/master/1-tictactoe/images/Screen%20Shot%202019-10-23%20at%204.31.51%20PM.png?raw=true" target="_blank" rel="noopener noreferrer"><img src="https://github.com/immrama87/game-ai/raw/master/1-tictactoe/images/Screen%20Shot%202019-10-23%20at%204.31.51%20PM.png?raw=true" alt="Cell availability check fails" style="max-width:100%;"></a></p>
<p>Now we're finally ready to build in a win condition. First we need to figure out what that means, in Tic Tac Toe, it's simply any full row, column or diagonal that is filled with the same token. In our GameState class, we can quantify these with a new multi-dimensional array that will allow us to check an initial cell on the game board and check all available win conditions related to that cell.</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">winConditions</span> <span class="pl-k">=</span> [
  [
    [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>],  <span class="pl-c"><span class="pl-c">//</span>Top Row</span>
    [<span class="pl-c1">3</span>,<span class="pl-c1">6</span>],  <span class="pl-c"><span class="pl-c">//</span>Left Column</span>
    [<span class="pl-c1">4</span>,<span class="pl-c1">8</span>]   <span class="pl-c"><span class="pl-c">//</span>Right-Down Diagonal</span>
  ],
  [
    [<span class="pl-c1">4</span>,<span class="pl-c1">7</span>]   <span class="pl-c"><span class="pl-c">//</span>Center Column</span>
  ],
  [
    [<span class="pl-c1">5</span>,<span class="pl-c1">8</span>],  <span class="pl-c"><span class="pl-c">//</span>Right Column</span>
    [<span class="pl-c1">4</span>,<span class="pl-c1">6</span>]   <span class="pl-c"><span class="pl-c">//</span>Left-Down Diagonal</span>
  ],
  [
    [<span class="pl-c1">4</span>,<span class="pl-c1">5</span>]   <span class="pl-c"><span class="pl-c">//</span>Center Row</span>
  ],
  [],
  [],
  [
    [<span class="pl-c1">7</span>,<span class="pl-c1">8</span>]   <span class="pl-c"><span class="pl-c">//</span>Bottom Row</span>
  ]
];</pre></div>
<p>With this array we can walk the first level of the array and, using the same index, check the game board for a token on that cell and if found, we can then check the secondary arrays to see if those cells contain the same token. The code for this in the GameState class would look like:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">gs</span>.<span class="pl-en">hasWinner</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
  <span class="pl-k">var</span> i;
  <span class="pl-k">for</span>(i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">winConditions</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
    <span class="pl-k">var</span> token;
    <span class="pl-k">if</span>((token <span class="pl-k">=</span> state[i]) <span class="pl-k">!=</span> <span class="pl-c1">0</span>){
      <span class="pl-k">var</span> j;
      <span class="pl-k">for</span>(j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> winConditions[i].<span class="pl-c1">length</span>; j<span class="pl-k">++</span>){
        <span class="pl-k">var</span> cells <span class="pl-k">=</span> winConditions[i][j];
        <span class="pl-k">if</span>(state[cells[<span class="pl-c1">0</span>]] <span class="pl-k">==</span> token <span class="pl-k">&amp;&amp;</span> state[cells[<span class="pl-c1">1</span>]] <span class="pl-k">==</span> token){
          <span class="pl-k">return</span> token;
        }
      }
    }
  }

  <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>
<p>Now we just need to link this code into our game loop, by adding it to the end of the render loop before the check for a stalemate, as it should be possible to completely fill the board and win on the same move:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> winner;
<span class="pl-k">if</span>((winner <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">hasWinner</span>()) <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>){
  <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">`</span>Player <span class="pl-s1"><span class="pl-pse">${</span>winner<span class="pl-pse">}</span></span> wins!<span class="pl-pds">`</span></span>);
  <span class="pl-c1">process</span>.<span class="pl-en">exit</span>();
}</pre></div>
<p>Now running <code>node index</code> and playing a game out to a win will give us something like</p>
<p><a href="https://github.com/immrama87/game-ai/blob/master/1-tictactoe/images/Screen%20Shot%202019-10-23%20at%204.55.39%20PM.png?raw=true" target="_blank" rel="noopener noreferrer"><img src="https://github.com/immrama87/game-ai/raw/master/1-tictactoe/images/Screen%20Shot%202019-10-23%20at%204.55.39%20PM.png?raw=true" alt="First win condition achieved!" style="max-width:100%;"></a></p>
<p>And with that, we have a working multiplayer (couch co-op!) Tic Tac Toe game.</p>
<p>At this point, we should have a /index.js file that looks like:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">readline</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>readline<span class="pl-pds">'</span></span>);
<span class="pl-k">const</span> <span class="pl-c1">cli</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./CLI<span class="pl-pds">'</span></span>)(<span class="pl-smi">readline</span>.<span class="pl-en">createInterface</span>({
  input<span class="pl-k">:</span> <span class="pl-c1">process</span>.<span class="pl-smi">stdin</span>,
  output<span class="pl-k">:</span> <span class="pl-c1">process</span>.<span class="pl-smi">stdout</span>
}));
<span class="pl-k">const</span> <span class="pl-c1">GameState</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./GameState<span class="pl-pds">'</span></span>);

<span class="pl-k">const</span> <span class="pl-c1">gameState</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">GameState</span>();
<span class="pl-k">const</span> <span class="pl-c1">stateTokens</span> <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>O<span class="pl-pds">'</span></span>]; <span class="pl-c"><span class="pl-c">//</span>State tokens to display the state of a game board cell</span>
<span class="pl-k">var</span> currentPlayer <span class="pl-k">=</span> <span class="pl-c1">0</span>;

<span class="pl-k">function</span> <span class="pl-en">render</span>(){
  <span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">getState</span>();
  <span class="pl-k">var</span> gameboard <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;

  <span class="pl-k">var</span> i, separator;
  <span class="pl-k">for</span>(i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">state</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
    separator <span class="pl-k">=</span> ((i <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">?</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>|<span class="pl-pds">'</span></span>;
    gameboard <span class="pl-k">+=</span> stateTokens[state[i]] <span class="pl-k">+</span> separator;
  }
  <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(gameboard);

  <span class="pl-k">var</span> winner;
  <span class="pl-k">if</span>((winner <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">hasWinner</span>()) <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>){
    <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">`</span>Player <span class="pl-s1"><span class="pl-pse">${</span>winner<span class="pl-pse">}</span></span> wins!<span class="pl-pds">`</span></span>);
    <span class="pl-c1">process</span>.<span class="pl-en">exit</span>();
  }

  <span class="pl-k">if</span>(<span class="pl-smi">gameState</span>.<span class="pl-en">hasEmptyCells</span>()){
    currentPlayer <span class="pl-k">=</span> (currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">%</span> <span class="pl-c1">2</span>; <span class="pl-c"><span class="pl-c">//</span>Make sure we're clamping it so there are only 2 players.</span>
    <span class="pl-en">promptForColumn</span>();
  }
  <span class="pl-k">else</span> {
    <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>There are no remaining moves to play. Stalemate!!!<span class="pl-pds">"</span></span>);
    <span class="pl-c1">process</span>.<span class="pl-en">exit</span>();
  }
}

<span class="pl-k">function</span> <span class="pl-en">validateInput</span>(<span class="pl-smi">str</span>){
  <span class="pl-k">var</span> num <span class="pl-k">=</span> <span class="pl-c1">parseInt</span>(str);
  <span class="pl-k">if</span>(<span class="pl-c1">isNaN</span>(num)){
    <span class="pl-k">return</span> <span class="pl-c1">false</span>; <span class="pl-c"><span class="pl-c">//</span>If the string is not parseable as an int, fail</span>
  }
  <span class="pl-k">if</span>(num <span class="pl-k">&lt;</span> <span class="pl-c1">1</span> <span class="pl-k">||</span> num <span class="pl-k">&gt;</span> <span class="pl-c1">3</span>){
    <span class="pl-k">return</span> <span class="pl-c1">false</span>; <span class="pl-c"><span class="pl-c">//</span>Makes sure the int is between 1 and 3</span>
  }

  <span class="pl-k">return</span> num <span class="pl-k">-</span> <span class="pl-c1">1</span>; <span class="pl-c"><span class="pl-c">//</span>0-index our number here</span>
}

<span class="pl-k">function</span> <span class="pl-en">promptForColumn</span>(){
  <span class="pl-smi">cli</span>.<span class="pl-c1">prompt</span>(<span class="pl-s"><span class="pl-pds">"</span>Enter a column: <span class="pl-pds">"</span></span>)
    .<span class="pl-c1">then</span>(<span class="pl-k">function</span> <span class="pl-en">resolved</span>(<span class="pl-smi">column</span>){
      column <span class="pl-k">=</span> <span class="pl-en">validateInput</span>(column);
      <span class="pl-k">if</span>(column <span class="pl-k">===</span> <span class="pl-c1">false</span>){
        <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>Column input must be a valid number between 1 and 3.<span class="pl-pds">"</span></span>);
        <span class="pl-en">promptForColumn</span>();
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
      }

      <span class="pl-en">promptForRow</span>(column);
    });
}

<span class="pl-k">function</span> <span class="pl-en">promptForRow</span>(<span class="pl-smi">column</span>){
  <span class="pl-smi">cli</span>.<span class="pl-c1">prompt</span>(<span class="pl-s"><span class="pl-pds">"</span>Enter a row: <span class="pl-pds">"</span></span>)
    .<span class="pl-c1">then</span>(<span class="pl-k">function</span> <span class="pl-en">resolved</span>(<span class="pl-smi">row</span>){
      row <span class="pl-k">=</span> <span class="pl-en">validateInput</span>(row);
      <span class="pl-k">if</span>(row <span class="pl-k">===</span> <span class="pl-c1">false</span>){
        <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>Row input must be a valid number between 1 and 3.<span class="pl-pds">"</span></span>);
        <span class="pl-en">promptForRow</span>(column);
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
      }

      <span class="pl-k">var</span> cell <span class="pl-k">=</span> (row <span class="pl-k">*</span> <span class="pl-c1">3</span>) <span class="pl-k">+</span> column;
      <span class="pl-k">if</span>(<span class="pl-smi">gameState</span>.<span class="pl-en">setCell</span>(cell, currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>)){
        <span class="pl-en">render</span>();
      }
      <span class="pl-k">else</span> {
        <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>The selected cell has already been played on. A cell must be empty in order to be played.<span class="pl-pds">"</span></span>);
        <span class="pl-en">promptForColumn</span>();
      }
    });
}

<span class="pl-en">promptForColumn</span>();</pre></div>
<p>and a /GameState/index.js file that looks like:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> GameState <span class="pl-k">=</span> (<span class="pl-k">function</span>(<span class="pl-smi">state</span>){
  state <span class="pl-k">=</span> state <span class="pl-k">||</span> [<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>];
  <span class="pl-k">const</span> <span class="pl-c1">winConditions</span> <span class="pl-k">=</span> [
    [
      [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>],  <span class="pl-c"><span class="pl-c">//</span>Top Row</span>
      [<span class="pl-c1">3</span>,<span class="pl-c1">6</span>],  <span class="pl-c"><span class="pl-c">//</span>Left Column</span>
      [<span class="pl-c1">4</span>,<span class="pl-c1">8</span>]   <span class="pl-c"><span class="pl-c">//</span>Right-Down Diagonal</span>
    ],
    [
      [<span class="pl-c1">4</span>,<span class="pl-c1">7</span>]   <span class="pl-c"><span class="pl-c">//</span>Center Column</span>
    ],
    [
      [<span class="pl-c1">5</span>,<span class="pl-c1">8</span>],  <span class="pl-c"><span class="pl-c">//</span>Right Column</span>
      [<span class="pl-c1">4</span>,<span class="pl-c1">6</span>]   <span class="pl-c"><span class="pl-c">//</span>Left-Down Diagonal</span>
    ],
    [
      [<span class="pl-c1">4</span>,<span class="pl-c1">5</span>]   <span class="pl-c"><span class="pl-c">//</span>Center Row</span>
    ],
    [],
    [],
    [
      [<span class="pl-c1">7</span>,<span class="pl-c1">8</span>]   <span class="pl-c"><span class="pl-c">//</span>Bottom Row</span>
    ]
  ];

  <span class="pl-k">var</span> gs <span class="pl-k">=</span> {};

  <span class="pl-smi">gs</span>.<span class="pl-en">hasEmptyCells</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-k">return</span> <span class="pl-smi">state</span>.<span class="pl-c1">indexOf</span>(<span class="pl-c1">0</span>) <span class="pl-k">&gt;</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
  }

  <span class="pl-smi">gs</span>.<span class="pl-en">hasWinner</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-k">var</span> i;
    <span class="pl-k">for</span>(i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">winConditions</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
      <span class="pl-k">var</span> token;
      <span class="pl-k">if</span>((token <span class="pl-k">=</span> state[i]) <span class="pl-k">!=</span> <span class="pl-c1">0</span>){
        <span class="pl-k">var</span> j;
        <span class="pl-k">for</span>(j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> winConditions[i].<span class="pl-c1">length</span>; j<span class="pl-k">++</span>){
          <span class="pl-k">var</span> cells <span class="pl-k">=</span> winConditions[i][j];
          <span class="pl-k">if</span>(state[cells[<span class="pl-c1">0</span>]] <span class="pl-k">==</span> token <span class="pl-k">&amp;&amp;</span> state[cells[<span class="pl-c1">1</span>]] <span class="pl-k">==</span> token){
            <span class="pl-k">return</span> token;
          }
        }
      }
    }

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
  }

  <span class="pl-smi">gs</span>.<span class="pl-en">setCell</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cell</span>, <span class="pl-smi">player</span>){
    <span class="pl-k">if</span>(state[cell] <span class="pl-k">==</span> <span class="pl-c1">0</span>){
      state[cell] <span class="pl-k">=</span> player;
      <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">return</span> <span class="pl-c1">false</span>;
  }

  <span class="pl-smi">gs</span>.<span class="pl-en">getState</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-k">return</span> state;
  }

  <span class="pl-k">return</span> gs;
});

<span class="pl-c1">module</span>.<span class="pl-smi">exports</span> <span class="pl-k">=</span> GameState;</pre></div>
<h3>
<a id="user-content-part-2-a-basic-ai" class="anchor" href="#part-2-a-basic-ai" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Part 2: A Basic AI</h3>
<p>Now that we have a playable game, it's time to teach it to play itself. We'll start with a fairly simple, brute-force AI that plays out every possible permutation of a game state and categorizes them based on potential wins vs. potential losses. Before we do that, though, let's just get a dumb "AI" running that randomly picks a cell to place its token on.</p>
<p>To start, we'll need to create a new directory, called AI, with a index.js file in our project folder. The index.js for our dumb AI will look like:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-c1">AI</span> <span class="pl-k">=</span> (<span class="pl-k">function</span>(){
  <span class="pl-k">var</span> ai <span class="pl-k">=</span> {};

  <span class="pl-smi">ai</span>.<span class="pl-en">selectCell</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">gameState</span>){
      <span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">getState</span>();

      <span class="pl-k">var</span> empty <span class="pl-k">=</span> [];
      <span class="pl-k">var</span> index <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
      <span class="pl-k">while</span>((index <span class="pl-k">=</span> <span class="pl-smi">state</span>.<span class="pl-c1">indexOf</span>(<span class="pl-c1">0</span>, index)) <span class="pl-k">&gt;</span> <span class="pl-k">-</span><span class="pl-c1">1</span>){
        <span class="pl-smi">empty</span>.<span class="pl-c1">push</span>(index);
      }

      <span class="pl-k">var</span> emptyIndex <span class="pl-k">=</span> <span class="pl-c1">Math</span>.<span class="pl-c1">floor</span>(<span class="pl-c1">Math</span>.<span class="pl-c1">random</span>() <span class="pl-k">*</span> <span class="pl-smi">empty</span>.<span class="pl-c1">length</span>);
      <span class="pl-k">return</span> empty[emptyIndex];
  }

  <span class="pl-k">return</span> ai;
});

<span class="pl-c1">module</span>.<span class="pl-smi">exports</span> <span class="pl-k">=</span> <span class="pl-c1">AI</span>;</pre></div>
<p>Now that we have a blind-firing AI, we'll need to do some reconfiguring of /index.js to enable the AI to play. Currently after a token is placed, we're just requesting input to place the next. Now that we have an "AI" we'll need to query it half the time.</p>
<p>To do this, we'll first need to <strong>require</strong> our new AI class like:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">ai</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./AI<span class="pl-pds">'</span></span>)();</pre></div>
<p>Next, we'll need a function that uses the AI to select a cell using the <em>selectCell</em> method, like:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">doAITurn</span>(){
  <span class="pl-k">var</span> cell <span class="pl-k">=</span> <span class="pl-smi">ai</span>.<span class="pl-en">selectCell</span>(gameState);
  <span class="pl-k">if</span>(<span class="pl-smi">gameState</span>.<span class="pl-en">setCell</span>(cell, currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>)){
      <span class="pl-en">render</span>();
  }
  <span class="pl-k">else</span> {
      <span class="pl-en">doAITurn</span>();
  }
}</pre></div>
<p>and then in the <strong>render</strong> function, we'll modify the code that restarts the loop to check which player should play next by changing:</p>
<div class="highlight highlight-source-js"><pre>currentPlayer <span class="pl-k">=</span> (currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">%</span> <span class="pl-c1">2</span>; <span class="pl-c"><span class="pl-c">//</span>Make sure we're clamping it so there are only 2 players.</span>
<span class="pl-en">promptForColumn</span>();</pre></div>
<p>to</p>
<div class="highlight highlight-source-js"><pre>currentPlayer <span class="pl-k">=</span> (currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">%</span> <span class="pl-c1">2</span>; <span class="pl-c"><span class="pl-c">//</span>Make sure we're clamping it so there are only 2 players.</span>
<span class="pl-k">if</span>(currentPlayer <span class="pl-k">==</span> <span class="pl-c1">0</span>){
  <span class="pl-en">promptForColumn</span>();
}
<span class="pl-k">else</span> {
  <span class="pl-en">doAITurn</span>();
}</pre></div>
<p>Now, when we run <code>node index</code> we're going to be trading turns with our new AI.</p>
<p>But it's not very fun. We have to actively try to lose at this point since the AI is just blindly throwing darts at the game board. So let's make it a little more fun and get our AI scoring all of the moves using the brute force method described previously.</p>
<p>We're going to do a little setup to make this possible, mainly by creating a method that enables the AI to clone a game state. So, we modify the /GameState/index.js file to include a new <strong>clone</strong> method:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">gs</span>.<span class="pl-en">clone</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
  <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">GameState</span>(<span class="pl-smi">state</span>.<span class="pl-c1">slice</span>(<span class="pl-c1">0</span>)); <span class="pl-c"><span class="pl-c">//</span>Need to slice the array so it's not passing a reference to the parent state.</span>
}</pre></div>
<p>Now, back to our AI in /AI/index.js, we'll need a function that can be recursively called to iterate over all of the possible game state permutations and score them based on potential wins and losses.</p>
<p>This will end up looking like:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">processGameState</span>(<span class="pl-smi">gameState</span>, <span class="pl-smi">cell</span>, <span class="pl-smi">moves</span>){
    moves <span class="pl-k">=</span> moves <span class="pl-k">||</span> <span class="pl-c1">0</span>;
    <span class="pl-k">var</span> player <span class="pl-k">=</span> (moves <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">?</span> <span class="pl-c1">2</span> <span class="pl-k">:</span> <span class="pl-c1">1</span>;
    <span class="pl-k">var</span> newState <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">clone</span>();

    <span class="pl-k">var</span> wins <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">if</span>(<span class="pl-smi">newState</span>.<span class="pl-en">setCell</span>(cell, player)){
      <span class="pl-k">if</span>(<span class="pl-smi">newState</span>.<span class="pl-en">hasWinner</span>()){
        <span class="pl-k">if</span>(player <span class="pl-k">==</span> <span class="pl-c1">2</span>){
          <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        }
        <span class="pl-k">else</span> {
          <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        }
      }
      <span class="pl-k">else</span> <span class="pl-k">if</span>(<span class="pl-smi">newState</span>.<span class="pl-en">hasEmptyCells</span>()){
        <span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-smi">newState</span>.<span class="pl-en">getState</span>();
        <span class="pl-k">var</span> index <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        <span class="pl-k">while</span>((index <span class="pl-k">=</span> <span class="pl-smi">state</span>.<span class="pl-c1">indexOf</span>(<span class="pl-c1">0</span>, index <span class="pl-k">+</span> <span class="pl-c1">1</span>)) <span class="pl-k">&gt;</span> <span class="pl-k">-</span><span class="pl-c1">1</span>){
          wins <span class="pl-k">+=</span> <span class="pl-en">processGameState</span>(newState, index, moves <span class="pl-k">+</span> <span class="pl-c1">1</span>);
        }

        <span class="pl-k">return</span> wins;
      }
      <span class="pl-k">else</span> {
        <span class="pl-k">return</span> <span class="pl-c1">0</span>;
      }
    }
    <span class="pl-k">else</span> {
        <span class="pl-c"><span class="pl-c">//</span>This shouldn't be possible since the indexes were preprocessed in ai.selectCell</span>
        <span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Invalid cell index tested by AI.<span class="pl-pds">"</span></span>);
        <span class="pl-c1">process</span>.<span class="pl-en">exit</span>(<span class="pl-c1">1</span>);
    }
}</pre></div>
<p>There's a fair bit to unpack here. First, our AI is going to be figuring out who is currently playing based on the number of moves that have occurred (even numbered moves will always be the AI since it is always initiating this check), next it places the appropriate token in the requested cell and checks if it triggered a win condition. If there was a win, this is reported back to the caller to increment or decrement a win counter. If no win occurred, but there are still moves remaining it will begin to recursively check all remaining moves for wins/losses. Finally it passes the accumulated win counter back up to the caller.</p>
<p>Now, we'll need to include this new functionality in the <strong>selectCell</strong> method, like:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">ai</span>.<span class="pl-en">selectCell</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">gameState</span>){
    <span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">getState</span>();
    <span class="pl-k">var</span> cells <span class="pl-k">=</span> {};

    <span class="pl-k">var</span> index <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
    <span class="pl-k">var</span> indexes <span class="pl-k">=</span> [];
    <span class="pl-k">while</span>((index <span class="pl-k">=</span> <span class="pl-smi">state</span>.<span class="pl-c1">indexOf</span>(<span class="pl-c1">0</span>, index <span class="pl-k">+</span> <span class="pl-c1">1</span>)) <span class="pl-k">&gt;</span> <span class="pl-k">-</span><span class="pl-c1">1</span>){
      cells[index] <span class="pl-k">=</span> <span class="pl-en">processGameState</span>(gameState, index);
      <span class="pl-smi">indexes</span>.<span class="pl-c1">push</span>(index);
    }

    <span class="pl-k">var</span> cell <span class="pl-k">=</span> indexes[<span class="pl-c1">0</span>];
    <span class="pl-k">var</span> highest <span class="pl-k">=</span> cells[cell];
    <span class="pl-k">for</span>(<span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">indexes</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
      <span class="pl-k">if</span>(cells[indexes[i]] <span class="pl-k">&gt;</span> highest){
        cell <span class="pl-k">=</span> indexes[i];
        highest <span class="pl-k">=</span> cells[cell];
      }
    }

    <span class="pl-k">return</span> cell;
}</pre></div>
<p>And that's it. Since /index.js is already pointed at that <strong>selectCell</strong> method, and expects an integer return value, we're good to start testing. At this point, the files we've changed in our project should contain:</p>
<p><code>/index.js</code></p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">readline</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>readline<span class="pl-pds">'</span></span>);
<span class="pl-k">const</span> <span class="pl-c1">cli</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./CLI<span class="pl-pds">'</span></span>)(<span class="pl-smi">readline</span>.<span class="pl-en">createInterface</span>({
 input<span class="pl-k">:</span> <span class="pl-c1">process</span>.<span class="pl-smi">stdin</span>,
 output<span class="pl-k">:</span> <span class="pl-c1">process</span>.<span class="pl-smi">stdout</span>
}));
<span class="pl-k">const</span> <span class="pl-c1">GameState</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./GameState<span class="pl-pds">'</span></span>);
<span class="pl-k">const</span> <span class="pl-c1">gameState</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">GameState</span>();

<span class="pl-k">const</span> <span class="pl-c1">ai</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./AI<span class="pl-pds">'</span></span>)();

<span class="pl-k">const</span> <span class="pl-c1">stateTokens</span> <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>O<span class="pl-pds">'</span></span>]; <span class="pl-c"><span class="pl-c">//</span>State tokens to display the state of a game board cell</span>
<span class="pl-k">var</span> currentPlayer <span class="pl-k">=</span> <span class="pl-c1">0</span>;

<span class="pl-k">function</span> <span class="pl-en">render</span>(){
 <span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">getState</span>();
 <span class="pl-k">var</span> gameboard <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;

 <span class="pl-k">var</span> i, separator;
 <span class="pl-k">for</span>(i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">state</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
   separator <span class="pl-k">=</span> ((i <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">?</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>|<span class="pl-pds">'</span></span>;
   gameboard <span class="pl-k">+=</span> stateTokens[state[i]] <span class="pl-k">+</span> separator;
 }
 <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(gameboard);

 <span class="pl-k">var</span> winner;
 <span class="pl-k">if</span>((winner <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">hasWinner</span>()) <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>){
   <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">`</span>Player <span class="pl-s1"><span class="pl-pse">${</span>winner<span class="pl-pse">}</span></span> wins!<span class="pl-pds">`</span></span>);
   <span class="pl-c1">process</span>.<span class="pl-en">exit</span>();
 }

 <span class="pl-k">if</span>(<span class="pl-smi">gameState</span>.<span class="pl-en">hasEmptyCells</span>()){
   currentPlayer <span class="pl-k">=</span> (currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">%</span> <span class="pl-c1">2</span>; <span class="pl-c"><span class="pl-c">//</span>Make sure we're clamping it so there are only 2 players.</span>
   <span class="pl-k">if</span>(currentPlayer <span class="pl-k">==</span> <span class="pl-c1">0</span>){
     <span class="pl-en">promptForColumn</span>();
   }
   <span class="pl-k">else</span> {
     <span class="pl-en">doAITurn</span>();
   }
 }
 <span class="pl-k">else</span> {
   <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>There are no remaining moves to play. Stalemate!!!<span class="pl-pds">"</span></span>);
   <span class="pl-c1">process</span>.<span class="pl-en">exit</span>();
 }
}

<span class="pl-k">function</span> <span class="pl-en">validateInput</span>(<span class="pl-smi">str</span>){
 <span class="pl-k">var</span> num <span class="pl-k">=</span> <span class="pl-c1">parseInt</span>(str);
 <span class="pl-k">if</span>(<span class="pl-c1">isNaN</span>(num)){
   <span class="pl-k">return</span> <span class="pl-c1">false</span>; <span class="pl-c"><span class="pl-c">//</span>If the string is not parseable as an int, fail</span>
 }
 <span class="pl-k">if</span>(num <span class="pl-k">&lt;</span> <span class="pl-c1">1</span> <span class="pl-k">||</span> num <span class="pl-k">&gt;</span> <span class="pl-c1">3</span>){
   <span class="pl-k">return</span> <span class="pl-c1">false</span>; <span class="pl-c"><span class="pl-c">//</span>Makes sure the int is between 1 and 3</span>
 }

 <span class="pl-k">return</span> num <span class="pl-k">-</span> <span class="pl-c1">1</span>; <span class="pl-c"><span class="pl-c">//</span>0-index our number here</span>
}

<span class="pl-k">function</span> <span class="pl-en">promptForColumn</span>(){
 <span class="pl-smi">cli</span>.<span class="pl-c1">prompt</span>(<span class="pl-s"><span class="pl-pds">"</span>Enter a column: <span class="pl-pds">"</span></span>)
   .<span class="pl-c1">then</span>(<span class="pl-k">function</span> <span class="pl-en">resolved</span>(<span class="pl-smi">column</span>){
     column <span class="pl-k">=</span> <span class="pl-en">validateInput</span>(column);
     <span class="pl-k">if</span>(column <span class="pl-k">===</span> <span class="pl-c1">false</span>){
       <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>Column input must be a valid number between 1 and 3.<span class="pl-pds">"</span></span>);
       <span class="pl-en">promptForColumn</span>();
       <span class="pl-k">return</span> <span class="pl-c1">false</span>;
     }

     <span class="pl-en">promptForRow</span>(column);
   });
}

<span class="pl-k">function</span> <span class="pl-en">promptForRow</span>(<span class="pl-smi">column</span>){
 <span class="pl-smi">cli</span>.<span class="pl-c1">prompt</span>(<span class="pl-s"><span class="pl-pds">"</span>Enter a row: <span class="pl-pds">"</span></span>)
   .<span class="pl-c1">then</span>(<span class="pl-k">function</span> <span class="pl-en">resolved</span>(<span class="pl-smi">row</span>){
     row <span class="pl-k">=</span> <span class="pl-en">validateInput</span>(row);
     <span class="pl-k">if</span>(row <span class="pl-k">===</span> <span class="pl-c1">false</span>){
       <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>Row input must be a valid number between 1 and 3.<span class="pl-pds">"</span></span>);
       <span class="pl-en">promptForRow</span>(column);
       <span class="pl-k">return</span> <span class="pl-c1">false</span>;
     }

     <span class="pl-k">var</span> cell <span class="pl-k">=</span> (row <span class="pl-k">*</span> <span class="pl-c1">3</span>) <span class="pl-k">+</span> column;
     <span class="pl-k">if</span>(<span class="pl-smi">gameState</span>.<span class="pl-en">setCell</span>(cell, currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>)){
       <span class="pl-en">render</span>();
     }
     <span class="pl-k">else</span> {
       <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>The selected cell has already been played on. A cell must be empty in order to be played.<span class="pl-pds">"</span></span>);
       <span class="pl-en">promptForColumn</span>();
     }
   });
}

<span class="pl-k">function</span> <span class="pl-en">doAITurn</span>(){
 <span class="pl-k">var</span> cell <span class="pl-k">=</span> <span class="pl-smi">ai</span>.<span class="pl-en">selectCell</span>(gameState);
 <span class="pl-k">if</span>(<span class="pl-smi">gameState</span>.<span class="pl-en">setCell</span>(cell, currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>)){
   <span class="pl-k">var</span> column <span class="pl-k">=</span> cell <span class="pl-k">%</span> <span class="pl-c1">3</span>;
   <span class="pl-k">var</span> row <span class="pl-k">=</span> (cell <span class="pl-k">-</span> column) <span class="pl-k">/</span> <span class="pl-c1">3</span>;

   <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">`</span>AI selects cell at column <span class="pl-s1"><span class="pl-pse">${</span>column <span class="pl-k">+</span> <span class="pl-c1">1</span><span class="pl-pse">}</span></span> and row <span class="pl-s1"><span class="pl-pse">${</span>row <span class="pl-k">+</span> <span class="pl-c1">1</span><span class="pl-pse">}</span></span>.<span class="pl-pds">`</span></span>);
   <span class="pl-en">render</span>();
 }
 <span class="pl-k">else</span> {
   <span class="pl-en">doAITurn</span>();
 }
}

<span class="pl-en">promptForColumn</span>();</pre></div>
<p><code>/AI/index.js</code></p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-c1">AI</span> <span class="pl-k">=</span> (<span class="pl-k">function</span>(){
  <span class="pl-k">var</span> ai <span class="pl-k">=</span> {};

  <span class="pl-k">function</span> <span class="pl-en">processGameState</span>(<span class="pl-smi">gameState</span>, <span class="pl-smi">cell</span>, <span class="pl-smi">moves</span>){
    moves <span class="pl-k">=</span> moves <span class="pl-k">||</span> <span class="pl-c1">0</span>;
    <span class="pl-k">var</span> player <span class="pl-k">=</span> (moves <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">?</span> <span class="pl-c1">2</span> <span class="pl-k">:</span> <span class="pl-c1">1</span>;
    <span class="pl-k">var</span> newState <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">clone</span>();

    <span class="pl-k">var</span> wins <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">if</span>(<span class="pl-smi">newState</span>.<span class="pl-en">setCell</span>(cell, player)){
      <span class="pl-k">if</span>(<span class="pl-smi">newState</span>.<span class="pl-en">hasWinner</span>()){
        <span class="pl-k">if</span>(player <span class="pl-k">==</span> <span class="pl-c1">2</span>){
          <span class="pl-k">return</span> <span class="pl-c1">1</span>;
        }
        <span class="pl-k">else</span> {
          <span class="pl-k">return</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        }
      }
      <span class="pl-k">else</span> <span class="pl-k">if</span>(<span class="pl-smi">newState</span>.<span class="pl-en">hasEmptyCells</span>()){
        <span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-smi">newState</span>.<span class="pl-en">getState</span>();
        <span class="pl-k">var</span> index <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
        <span class="pl-k">while</span>((index <span class="pl-k">=</span> <span class="pl-smi">state</span>.<span class="pl-c1">indexOf</span>(<span class="pl-c1">0</span>, index <span class="pl-k">+</span> <span class="pl-c1">1</span>)) <span class="pl-k">&gt;</span> <span class="pl-k">-</span><span class="pl-c1">1</span>){
          wins <span class="pl-k">+=</span> <span class="pl-en">processGameState</span>(newState, index, moves <span class="pl-k">+</span> <span class="pl-c1">1</span>);
        }

        <span class="pl-k">return</span> wins;
      }
      <span class="pl-k">else</span> {
        <span class="pl-k">return</span> <span class="pl-c1">0</span>;
      }
    }
    <span class="pl-k">else</span> {
        <span class="pl-c"><span class="pl-c">//</span>This shouldn't be possible since the indexes were preprocessed in ai.selectCell</span>
        <span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Invalid cell index tested by AI.<span class="pl-pds">"</span></span>);
        <span class="pl-c1">process</span>.<span class="pl-en">exit</span>(<span class="pl-c1">1</span>);
    }
  }

  <span class="pl-smi">ai</span>.<span class="pl-en">selectCell</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">gameState</span>){
    <span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">getState</span>();
    <span class="pl-k">var</span> cells <span class="pl-k">=</span> {};

    <span class="pl-k">var</span> index <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
    <span class="pl-k">var</span> indexes <span class="pl-k">=</span> [];
    <span class="pl-k">while</span>((index <span class="pl-k">=</span> <span class="pl-smi">state</span>.<span class="pl-c1">indexOf</span>(<span class="pl-c1">0</span>, index <span class="pl-k">+</span> <span class="pl-c1">1</span>)) <span class="pl-k">&gt;</span> <span class="pl-k">-</span><span class="pl-c1">1</span>){
      cells[index] <span class="pl-k">=</span> <span class="pl-en">processGameState</span>(gameState, index);
      <span class="pl-smi">indexes</span>.<span class="pl-c1">push</span>(index);
    }

    <span class="pl-k">var</span> cell <span class="pl-k">=</span> indexes[<span class="pl-c1">0</span>];
    <span class="pl-k">var</span> highest <span class="pl-k">=</span> cells[cell];
    <span class="pl-k">for</span>(<span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">indexes</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
      <span class="pl-k">if</span>(cells[indexes[i]] <span class="pl-k">&gt;</span> highest){
        cell <span class="pl-k">=</span> indexes[i];
        highest <span class="pl-k">=</span> cells[cell];
      }
    }

    <span class="pl-k">return</span> cell;
  }

  <span class="pl-k">return</span> ai;
});

<span class="pl-c1">module</span>.<span class="pl-smi">exports</span> <span class="pl-k">=</span> <span class="pl-c1">AI</span>;</pre></div>
<p>everything else, except for the <strong>GameState#clone</strong> method should be the same as it was at the end of part 1.</p>
<h3>
<a id="user-content-part-3-the-best-offense" class="anchor" href="#part-3-the-best-offense" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Part 3: The Best Offense?</h3>
<p>At this point, if you've played a game against your AI, you'll have probably noticed that it does not quite hit the mark we were shooting for. If you're not sure what that means, try playing a game with the following moves:</p>
<p><strong>Move 1:</strong> Column 1, Row 1</p>
<p><em>AI selects cell at column 2 and row 2</em></p>
<p><strong>Move 2:</strong> Column 3, Row 3</p>
<p><em>AI selects cell at column 3 and row 1</em></p>
<p><strong>Move 3:</strong> Column 1, Row 3</p>
<p><em>AI selects cell at column 1 and row 2</em></p>
<p><strong>Move 4:</strong> Column 2, Row 3</p>
<p><em>Player 1 Wins!</em></p>
<p>Obviously, this is not what we want. The goal for our AI is that it will always be able to force either a stalemate or a loss. As it turns out our brute force method of evaluating every permuation of the game from its current state is not only the least efficient manner of categorizing the strength of any particular move, but it's also generating a subpar result.</p>
<p>What's happening is that our AI is missing critical information in order to determine its best move, in terms of both its efficiency and its efficacy. At this point we've only given our AI the ability to evaluate the current state and determine what moves are available, then ask the GameState instance to tell it whether or not any given move will produce a win state. We haven't actually taught it how to win, just how to tell if it <em>has</em> won. Teaching it how to win opens up our options pretty substantially, because it also gives it the ability to evaluate whether or not it can force its opponent's hand. If we were to replay the game above, but pick a different cell on the AI's second move, we'll see:</p>
<p><strong>Move 1:</strong> Column 1, Row 1</p>
<p><em>AI selects cell at column 2 and row 2</em></p>
<p><strong>Move 2:</strong> Column 3, Row 3</p>
<p><em>AI selects cell at column 1 and row 2</em></p>
<p>Here the AI has created a situation where, if the player were to play the same cell as before (Column 1, Row 3), the AI can play the cell at column 3 and row 2 and win the game, forcing the player to play that cell. Continuing this game with ideal (or forced) moves, we see:</p>
<p><strong>Move 3:</strong> Column 3, Row 2</p>
<p><em>AI selects cell at column 3 and row 1</em></p>
<p><strong>Move 4:</strong> Column 1, Row 3</p>
<p><em>AI selects cell at column 2 and row 3</em></p>
<p><strong>Move 5:</strong> Column 2, Row 1</p>
<p>There are no remaining moves to play. Stalemate!!!</p>
<p>This is more like it! The simulated AI in the above example has forced a stalemate by taking control of the player's next move and ensuring that they either play the required blocking move or lose on the AI's next move.</p>
<p>So, how do we teach our AI to employ a similar strategy?</p>
<p>First, we need to make it more efficient, because as it stands the <strong>processGameState</strong> algorithm executes with a time-complexity of O(n!) and adding additional categorization will cause the real-time execution of each AI move to most likely become noticable to the player (also, there's really no need to be that inefficient). To do this, the AI is going to need to be aware of the win conditions for the game.</p>
<p>By using the same win conditions that are already present in the GameState class, we can rewrite our algorithm to look at the number of win conditions that remain available for any given space to come to the same answer. Using the opening move of the example games, we would get:</p>
<table>
<thead>
<tr>
<th></th>
<th>C1</th>
<th>C2</th>
<th>C3</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>R1</strong></td>
<td>X</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td><strong>R2</strong></td>
<td>1</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td><strong>R3</strong></td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>So our AI would still play the cell at column 2 and row 2, because its column, its row and one of the diagonals still remain completely open, leaving 3 win states available. To achieve this, we must first expose the <strong>winConditions</strong> array in the GameState class (ideally through a getter method so it can't be modified to cheat) like so:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">gs</span>.<span class="pl-en">getWinConditions</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-k">return</span> winConditions;
}</pre></div>
<p>then, in our AI class, modify the "constructor" to require this as a parameter:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-c1">AI</span> <span class="pl-k">=</span> (<span class="pl-k">function</span>(<span class="pl-smi">winConditions</span>){</pre></div>
<p>Finally, in /index.js, modify our AI instantiation to:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">ai</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./AI<span class="pl-pds">'</span></span>)(<span class="pl-smi">gameState</span>.<span class="pl-en">getWinConditions</span>());</pre></div>
<p><em>Note: If during testing, you receive an error about gameState being undefined, check the order of your <strong>require</strong>s and instance declarations.</em></p>
<p>Now that we've passed the knowledge of how to win on to our AI, we can modify the <strong>processGameState</strong> function to:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">processGameState</span>(<span class="pl-smi">gameState</span>, <span class="pl-smi">cell</span>){
    <span class="pl-k">var</span> newState <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">clone</span>();
    <span class="pl-k">if</span>(<span class="pl-k">!</span><span class="pl-smi">newState</span>.<span class="pl-en">setCell</span>(cell, player)){
      <span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Invalid cell index tested by AI.<span class="pl-pds">"</span></span>);
      <span class="pl-c1">process</span>.<span class="pl-en">exit</span>(<span class="pl-c1">1</span>);
    }
    <span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-smi">newState</span>.<span class="pl-en">getState</span>();
    <span class="pl-k">var</span> wins <span class="pl-k">=</span> <span class="pl-c1">0</span>;

    <span class="pl-k">for</span>(<span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">winConditions</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
      <span class="pl-k">if</span>(i <span class="pl-k">==</span> cell <span class="pl-k">||</span> state[i] <span class="pl-k">==</span> player <span class="pl-k">||</span> state[i] <span class="pl-k">==</span> <span class="pl-c1">0</span>){
        <span class="pl-k">for</span>(<span class="pl-k">var</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> winConditions[i].<span class="pl-c1">length</span>; j<span class="pl-k">++</span>){
          <span class="pl-k">var</span> firstCell <span class="pl-k">=</span> (winConditions[i][j][<span class="pl-c1">0</span>] <span class="pl-k">==</span> cell <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">0</span>]] <span class="pl-k">==</span> player <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">0</span>]] <span class="pl-k">==</span> <span class="pl-c1">0</span>);
          <span class="pl-k">var</span> secondCell <span class="pl-k">=</span> (winConditions[i][j][<span class="pl-c1">1</span>] <span class="pl-k">==</span> cell <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">1</span>]] <span class="pl-k">==</span> player <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">1</span>]] <span class="pl-k">==</span> <span class="pl-c1">0</span>);
          <span class="pl-k">var</span> isInCondition <span class="pl-k">=</span> (i <span class="pl-k">==</span> cell <span class="pl-k">||</span> winConditions[i][j][<span class="pl-c1">0</span>] <span class="pl-k">==</span> cell <span class="pl-k">||</span> winConditions[i][j][<span class="pl-c1">1</span>] <span class="pl-k">==</span> cell);

          <span class="pl-k">if</span>(firstCell <span class="pl-k">&amp;&amp;</span> secondCell <span class="pl-k">&amp;&amp;</span> isInCondition){
            wins<span class="pl-k">++</span>;
          }
        }
      }
}

    <span class="pl-k">return</span> wins;
    }</pre></div>
<p>First, we remove the <strong>moves</strong> counter, because it is no longer necessary. Next, we've been able to significantly simplified our AI state testing logic by testing first if the "index" cell for each win condition is either the one which is being played, empty or already played with the AI's token, then checking whether or not the first and second cells stored in the array at that index are also either the cell being played, already owned by the AI or empty. Finally we need to ensure that the cell is actually one of the three cells in that win condition, since the other three conditions do not preclude the possibility that this is not the case. We end up getting the exact same results as before, but we've managed to do it with an algorithm which will execute with a time-complexity of simply O(n) because we've removed all of the recursion in the original brute-force method. If you play a game now, you'll notice that the AI's second move changes to Column 2, Row 1, which is a technically correct move, but it's selecting it for the wrong reasons as you'll see below (keep in mind that Column 2, Row 1 will be the first cell evaluated).</p>
<p>Now, it's time to teach our AI how to play some offense. The simplest way to do this would be to iterate the wins counter an additional time if it's determined that placing a token on a cell will setup the player to secure a win condition on the next turn. Applying this to the example game on the move where the AI's loss was secured, however, would result in:</p>
<table>
<thead>
<tr>
<th></th>
<th>C1</th>
<th>C2</th>
<th>C3</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>R1</strong></td>
<td>X</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td><strong>R2</strong></td>
<td>2</td>
<td>O</td>
<td>2</td>
</tr>
<tr>
<td><strong>R3</strong></td>
<td>2</td>
<td>2</td>
<td>X</td>
</tr>
</tbody>
</table>
<p>with equal value assigned to each cell, so if the AI were to then select randomly from the seemingly equal cells it has a 33% chance to select a corner cell which will force a loss in two turns. However, since all of these moves are forcing the opponent's next move, we can add a lookahead to evaluate the strength of that move in the opponent's favor and subtract that score from the score of the cell. This will end up looking like:</p>
<table>
<thead>
<tr>
<th></th>
<th>C1</th>
<th>C2</th>
<th>C3</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>R1</strong></td>
<td>X</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><strong>R2</strong></td>
<td>1</td>
<td>O</td>
<td>1</td>
</tr>
<tr>
<td><strong>R3</strong></td>
<td>0</td>
<td>1</td>
<td>X</td>
</tr>
</tbody>
</table>
<p>This is exactly what we're looking for! First, we're going to need a new function to process the opponent's outlook, since all we are looking for is win conditions which the opponent is only one cell away from playing in order to secure. This will be:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">processOpponentState</span>(<span class="pl-smi">gameState</span>, <span class="pl-smi">cell</span>){
    <span class="pl-k">var</span> player <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-k">var</span> newState <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">clone</span>();
    <span class="pl-k">if</span>(<span class="pl-k">!</span><span class="pl-smi">newState</span>.<span class="pl-en">setCell</span>(cell, player)){
      <span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Invalid cell index tested by AI in opponent prediction.<span class="pl-pds">"</span></span>);
      <span class="pl-c1">process</span>.<span class="pl-en">exit</span>(<span class="pl-c1">1</span>);
    }

    <span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-smi">newState</span>.<span class="pl-en">getState</span>();
    <span class="pl-k">var</span> wins <span class="pl-k">=</span> <span class="pl-c1">0</span>;

    <span class="pl-k">for</span>(<span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">winConditions</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
      <span class="pl-k">if</span>(i <span class="pl-k">==</span> cell <span class="pl-k">||</span> state[i] <span class="pl-k">==</span> player <span class="pl-k">||</span> state[i] <span class="pl-k">==</span> <span class="pl-c1">0</span>){
        <span class="pl-k">for</span>(<span class="pl-k">var</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> winConditions[i].<span class="pl-c1">length</span>; j<span class="pl-k">++</span>){
          <span class="pl-k">var</span> firstCell <span class="pl-k">=</span> (winConditions[i][j][<span class="pl-c1">0</span>] <span class="pl-k">==</span> cell <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">0</span>]] <span class="pl-k">==</span> player <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">0</span>]] <span class="pl-k">==</span> <span class="pl-c1">0</span>);
          <span class="pl-k">var</span> secondCell <span class="pl-k">=</span> (winConditions[i][j][<span class="pl-c1">1</span>] <span class="pl-k">==</span> cell <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">1</span>]] <span class="pl-k">==</span> player <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">1</span>]] <span class="pl-k">==</span> <span class="pl-c1">0</span>);
          <span class="pl-k">var</span> isInCondition <span class="pl-k">=</span> (i <span class="pl-k">==</span> cell <span class="pl-k">||</span> winConditions[i][j][<span class="pl-c1">0</span>] <span class="pl-k">==</span> cell <span class="pl-k">||</span> winConditions[i][j][<span class="pl-c1">1</span>] <span class="pl-k">==</span> cell);
          <span class="pl-k">var</span> cellsTotal <span class="pl-k">=</span> state[i] <span class="pl-k">+</span> state[winConditions[i][j][<span class="pl-c1">0</span>]] <span class="pl-k">+</span> state[winConditions[i][j][<span class="pl-c1">1</span>]];

          <span class="pl-k">if</span>(firstCell <span class="pl-k">&amp;&amp;</span> secondCell <span class="pl-k">&amp;&amp;</span> isInCondition <span class="pl-k">&amp;&amp;</span> cellsTotal <span class="pl-k">==</span> (player <span class="pl-k">*</span> <span class="pl-c1">2</span>)){
            wins<span class="pl-k">++</span>;
          }
        }
      }
    }

    <span class="pl-k">return</span> wins;
}</pre></div>
<p>This looks nearly identical to the <strong>processGameState</strong> function, with the addition of the <strong>cellsTotal</strong> variable. We are using this new variable in order to find how many "token points" are set for win condition that the AI is evaluating. If this is equal to twice the current player's token value then, as we've also determined that it is a win condition the current player can still claim, we can be certain that there are two tokens played and we are examining a win condition which is one move away from being secured.</p>
<p>Now, we need to do something similar with <strong>processGameState</strong>, and additionally call our new function to decrement the wins counter. This will only be required when the win condition is valid for the played cell, so we can add it to the final conditional block, like:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">if</span>(firstCell <span class="pl-k">&amp;&amp;</span> secondCell <span class="pl-k">&amp;&amp;</span> isInCondition){
    wins<span class="pl-k">++</span>;

    <span class="pl-k">var</span> cellsTotal <span class="pl-k">=</span> state[i] <span class="pl-k">+</span> state[winConditions[i][j][<span class="pl-c1">0</span>]] <span class="pl-k">+</span> state[winConditions[i][j][<span class="pl-c1">1</span>]];
    <span class="pl-k">if</span>(cellsTotal <span class="pl-k">==</span> (player <span class="pl-k">*</span> <span class="pl-c1">2</span>)){
        wins<span class="pl-k">++</span>;

        <span class="pl-k">var</span> targetCell <span class="pl-k">=</span> (state[i] <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">?</span> i <span class="pl-k">:</span> (state[winConditions[i][j][<span class="pl-c1">0</span>]] <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">?</span> winConditions[i][j][<span class="pl-c1">0</span>] <span class="pl-k">:</span> winConditions[i][j][<span class="pl-c1">1</span>];
        wins <span class="pl-k">-=</span> <span class="pl-en">processOpponentState</span>(newState, targetCell);
    }
}</pre></div>
<p>Now, if we run <code>node index</code>, we should be able to get the results we were expecting, at least for one extra move. Now, the original example plays out like:</p>
<p><strong>Move 1:</strong> Column 1, Row 1</p>
<p><em>AI selects cell at column 2 and row 2</em></p>
<p><strong>Move 2:</strong> Column 3, Row 3</p>
<p><em>AI selects cell at column 2 and row 1</em></p>
<p><strong>Move 3:</strong> Column 2, Row 3</p>
<p><em>AI selects cell at column 3 and row 1</em></p>
<p><strong>Move 4:</strong> Column 1, Row 3</p>
<p>Player 1 wins!</p>
<p>And here's the problem: with its 3rd move, the AI has now left open a position which secures a win for its opponent. Based on what we've taught the AI so far after the opponent's 3rd move, all remaining spaces will evaluate equally to:</p>
<table>
<thead>
<tr>
<th></th>
<th>C1</th>
<th>C2</th>
<th>C3</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>R1</strong></td>
<td>X</td>
<td>O</td>
<td>1</td>
</tr>
<tr>
<td><strong>R2</strong></td>
<td>1</td>
<td>O</td>
<td>1</td>
</tr>
<tr>
<td><strong>R3</strong></td>
<td>1</td>
<td>X</td>
<td>X</td>
</tr>
</tbody>
</table>
<p>The AI is now able to force an opponent's move, but is not yet able to see when it should be forced to play one of its own. To handle this, we'll add a simple preprocessing function to find any win conditions that only require one cell to be secured:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">hasImminentWin</span>(<span class="pl-smi">gameState</span>, <span class="pl-smi">cell</span>, <span class="pl-smi">player</span>){
    <span class="pl-k">var</span> player <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-k">var</span> newState <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">clone</span>();
    <span class="pl-k">if</span>(<span class="pl-k">!</span><span class="pl-smi">newState</span>.<span class="pl-en">setCell</span>(cell, player)){
        <span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Invalid cell index tested by AI in opponent win pre-scan<span class="pl-pds">"</span></span>);
        <span class="pl-c1">process</span>.<span class="pl-en">exit</span>(<span class="pl-c1">1</span>);
    }

    <span class="pl-k">return</span> <span class="pl-smi">newState</span>.<span class="pl-en">hasWinner</span>();
}</pre></div>
<p>In the <strong>selectCell</strong> method, we'll start by adding a new array, <strong>opponentWins</strong> (although we could get away with simply an int here, it's best not to make any assumptions) and in the while loop for testing available cells in the <strong>selectCell</strong> method, we'll prepend the game state processing with a check for imminent win conditions. The AI will then prioritize the cells in the following order:</p>
<ol>
<li>Win secured for AI (since it doesn't matter if the opponent can win next turn if they've already lost)</li>
<li>Win secured for the opponent</li>
<li>Processed, ideal move</li>
</ol>
<div class="highlight highlight-source-js"><pre><span class="pl-k">while</span>((index <span class="pl-k">=</span> <span class="pl-smi">state</span>.<span class="pl-c1">indexOf</span>(<span class="pl-c1">0</span>, index <span class="pl-k">+</span> <span class="pl-c1">1</span>)) <span class="pl-k">&gt;</span> <span class="pl-k">-</span><span class="pl-c1">1</span>){
    <span class="pl-k">if</span>(<span class="pl-en">hasImminentWin</span>(gameState, index, <span class="pl-c1">2</span>)){
        <span class="pl-k">return</span> index;
    }
    <span class="pl-k">if</span>(<span class="pl-en">hasImminentWin</span>(gameState, index, <span class="pl-c1">1</span>)){
        <span class="pl-smi">opponentWins</span>.<span class="pl-c1">push</span>(index);
    }
    cells[index] <span class="pl-k">=</span> <span class="pl-en">processGameState</span>(gameState, index);
    <span class="pl-smi">indexes</span>.<span class="pl-c1">push</span>(index);
}</pre></div>
<p>And before we process the cell win values, we'll need to add:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">if</span>(<span class="pl-smi">opponentWins</span>.<span class="pl-c1">length</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>){
    <span class="pl-k">return</span> opponentWins[<span class="pl-c1">Math</span>.<span class="pl-c1">floor</span>(<span class="pl-c1">Math</span>.<span class="pl-c1">random</span>() <span class="pl-k">*</span> <span class="pl-smi">opponentWins</span>.<span class="pl-c1">length</span>)];
}</pre></div>
<p>And now, if we replay the game we'll get:</p>
<p><strong>Move 1:</strong> Column 1, Row 1</p>
<p><em>AI selects cell at column 2 and row 2</em></p>
<p><strong>Move 2:</strong> Column 3, Row 3</p>
<p><em>AI selects cell at column 2 and row 1</em></p>
<p><strong>Move 3:</strong> Column 2, Row 3</p>
<p><em>AI selects cell at column 1 and row 3</em></p>
<p><strong>Move 4:</strong> Column 3, Row 1</p>
<p><em>AI selects cell at column 3 and row 2</em></p>
<p><strong>Move 5:</strong> Column 1, Row 2</p>
<p>There are no remaining moves to play. Stalemate!!!</p>
<p>And, if we misplay:</p>
<p><strong>Move 1:</strong> Column 1, Row 1</p>
<p><em>AI selects cell at column 2 and row 2</em></p>
<p><strong>Move 2:</strong> Column 3, Row 3</p>
<p><em>AI selects cell at column 2 and row 1</em></p>
<p><strong>Move 3:</strong> Column 3, Row 1</p>
<p><em>AI selects cell at column 2 and row 3</em></p>
<p>Player 2 wins!</p>
<p>We've now taught the AI to keep itself from losing and to also punish opponent mistakes. We've done what we set out to. There are a couple of things that could be done to enhance this, like allowing the player to select whether they go first or second and allowing the AI to choose which cell to play when more than one exists which is considered "ideal" for the current state, but I'll leave that as homework for the reader since it doesn't have any effect on the core AI logic.</p>
<p>For reference, the files in our project directory should contain:</p>
<p><code>/index.js</code></p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">readline</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>readline<span class="pl-pds">'</span></span>);
<span class="pl-k">const</span> <span class="pl-c1">cli</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./CLI<span class="pl-pds">'</span></span>)(<span class="pl-smi">readline</span>.<span class="pl-en">createInterface</span>({
  input<span class="pl-k">:</span> <span class="pl-c1">process</span>.<span class="pl-smi">stdin</span>,
  output<span class="pl-k">:</span> <span class="pl-c1">process</span>.<span class="pl-smi">stdout</span>
}));
<span class="pl-k">const</span> <span class="pl-c1">GameState</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./GameState<span class="pl-pds">'</span></span>);
<span class="pl-k">const</span> <span class="pl-c1">gameState</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">GameState</span>();

<span class="pl-k">const</span> <span class="pl-c1">ai</span> <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./AI<span class="pl-pds">'</span></span>)(<span class="pl-smi">gameState</span>.<span class="pl-en">getWinConditions</span>());

<span class="pl-k">const</span> <span class="pl-c1">stateTokens</span> <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">'</span>-<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>O<span class="pl-pds">'</span></span>]; <span class="pl-c"><span class="pl-c">//</span>State tokens to display the state of a game board cell</span>
<span class="pl-k">var</span> currentPlayer <span class="pl-k">=</span> <span class="pl-c1">0</span>;

<span class="pl-k">function</span> <span class="pl-en">render</span>(){
  <span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">getState</span>();
  <span class="pl-k">var</span> gameboard <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>;

  <span class="pl-k">var</span> i, separator;
  <span class="pl-k">for</span>(i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">state</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
    separator <span class="pl-k">=</span> ((i <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">?</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>|<span class="pl-pds">'</span></span>;
    gameboard <span class="pl-k">+=</span> stateTokens[state[i]] <span class="pl-k">+</span> separator;
  }
  <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(gameboard);

  <span class="pl-k">var</span> winner;
  <span class="pl-k">if</span>((winner <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">hasWinner</span>()) <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>){
    <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">`</span>Player <span class="pl-s1"><span class="pl-pse">${</span>winner<span class="pl-pse">}</span></span> wins!<span class="pl-pds">`</span></span>);
    <span class="pl-c1">process</span>.<span class="pl-en">exit</span>();
  }

  <span class="pl-k">if</span>(<span class="pl-smi">gameState</span>.<span class="pl-en">hasEmptyCells</span>()){
    currentPlayer <span class="pl-k">=</span> (currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">%</span> <span class="pl-c1">2</span>; <span class="pl-c"><span class="pl-c">//</span>Make sure we're clamping it so there are only 2 players.</span>
    <span class="pl-k">if</span>(currentPlayer <span class="pl-k">==</span> <span class="pl-c1">0</span>){
      <span class="pl-en">promptForColumn</span>();
    }
    <span class="pl-k">else</span> {
      <span class="pl-en">doAITurn</span>();
    }
  }
  <span class="pl-k">else</span> {
    <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>There are no remaining moves to play. Stalemate!!!<span class="pl-pds">"</span></span>);
    <span class="pl-c1">process</span>.<span class="pl-en">exit</span>();
  }
}

<span class="pl-k">function</span> <span class="pl-en">validateInput</span>(<span class="pl-smi">str</span>){
  <span class="pl-k">var</span> num <span class="pl-k">=</span> <span class="pl-c1">parseInt</span>(str);
  <span class="pl-k">if</span>(<span class="pl-c1">isNaN</span>(num)){
    <span class="pl-k">return</span> <span class="pl-c1">false</span>; <span class="pl-c"><span class="pl-c">//</span>If the string is not parseable as an int, fail</span>
  }
  <span class="pl-k">if</span>(num <span class="pl-k">&lt;</span> <span class="pl-c1">1</span> <span class="pl-k">||</span> num <span class="pl-k">&gt;</span> <span class="pl-c1">3</span>){
    <span class="pl-k">return</span> <span class="pl-c1">false</span>; <span class="pl-c"><span class="pl-c">//</span>Makes sure the int is between 1 and 3</span>
  }

  <span class="pl-k">return</span> num <span class="pl-k">-</span> <span class="pl-c1">1</span>; <span class="pl-c"><span class="pl-c">//</span>0-index our number here</span>
}

<span class="pl-k">function</span> <span class="pl-en">promptForColumn</span>(){
  <span class="pl-smi">cli</span>.<span class="pl-c1">prompt</span>(<span class="pl-s"><span class="pl-pds">"</span>Enter a column: <span class="pl-pds">"</span></span>)
    .<span class="pl-c1">then</span>(<span class="pl-k">function</span> <span class="pl-en">resolved</span>(<span class="pl-smi">column</span>){
      column <span class="pl-k">=</span> <span class="pl-en">validateInput</span>(column);
      <span class="pl-k">if</span>(column <span class="pl-k">===</span> <span class="pl-c1">false</span>){
        <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>Column input must be a valid number between 1 and 3.<span class="pl-pds">"</span></span>);
        <span class="pl-en">promptForColumn</span>();
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
      }

      <span class="pl-en">promptForRow</span>(column);
    });
}

<span class="pl-k">function</span> <span class="pl-en">promptForRow</span>(<span class="pl-smi">column</span>){
  <span class="pl-smi">cli</span>.<span class="pl-c1">prompt</span>(<span class="pl-s"><span class="pl-pds">"</span>Enter a row: <span class="pl-pds">"</span></span>)
    .<span class="pl-c1">then</span>(<span class="pl-k">function</span> <span class="pl-en">resolved</span>(<span class="pl-smi">row</span>){
      row <span class="pl-k">=</span> <span class="pl-en">validateInput</span>(row);
      <span class="pl-k">if</span>(row <span class="pl-k">===</span> <span class="pl-c1">false</span>){
        <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>Row input must be a valid number between 1 and 3.<span class="pl-pds">"</span></span>);
        <span class="pl-en">promptForRow</span>(column);
        <span class="pl-k">return</span> <span class="pl-c1">false</span>;
      }

      <span class="pl-k">var</span> cell <span class="pl-k">=</span> (row <span class="pl-k">*</span> <span class="pl-c1">3</span>) <span class="pl-k">+</span> column;
      <span class="pl-k">if</span>(<span class="pl-smi">gameState</span>.<span class="pl-en">setCell</span>(cell, currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>)){
        <span class="pl-en">render</span>();
      }
      <span class="pl-k">else</span> {
        <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span>The selected cell has already been played on. A cell must be empty in order to be played.<span class="pl-pds">"</span></span>);
        <span class="pl-en">promptForColumn</span>();
      }
    });
}

<span class="pl-k">function</span> <span class="pl-en">doAITurn</span>(){
  <span class="pl-k">var</span> cell <span class="pl-k">=</span> <span class="pl-smi">ai</span>.<span class="pl-en">selectCell</span>(gameState);
  <span class="pl-k">if</span>(<span class="pl-smi">gameState</span>.<span class="pl-en">setCell</span>(cell, currentPlayer <span class="pl-k">+</span> <span class="pl-c1">1</span>)){
    <span class="pl-k">var</span> column <span class="pl-k">=</span> cell <span class="pl-k">%</span> <span class="pl-c1">3</span>;
    <span class="pl-k">var</span> row <span class="pl-k">=</span> (cell <span class="pl-k">-</span> column) <span class="pl-k">/</span> <span class="pl-c1">3</span>;

    <span class="pl-smi">cli</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">`</span>AI selects cell at column <span class="pl-s1"><span class="pl-pse">${</span>column <span class="pl-k">+</span> <span class="pl-c1">1</span><span class="pl-pse">}</span></span> and row <span class="pl-s1"><span class="pl-pse">${</span>row <span class="pl-k">+</span> <span class="pl-c1">1</span><span class="pl-pse">}</span></span>.<span class="pl-pds">`</span></span>);
    <span class="pl-en">render</span>();
  }
  <span class="pl-k">else</span> {
    <span class="pl-en">doAITurn</span>();
  }
}

<span class="pl-en">promptForColumn</span>();</pre></div>
<p><code>/AI/index.js</code></p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-c1">AI</span> <span class="pl-k">=</span> (<span class="pl-k">function</span>(<span class="pl-smi">winConditions</span>){
  <span class="pl-k">var</span> ai <span class="pl-k">=</span> {};

  <span class="pl-k">function</span> <span class="pl-en">processGameState</span>(<span class="pl-smi">gameState</span>, <span class="pl-smi">cell</span>){
    <span class="pl-k">var</span> player <span class="pl-k">=</span> <span class="pl-c1">2</span>;
    <span class="pl-k">var</span> newState <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">clone</span>();
    <span class="pl-k">if</span>(<span class="pl-k">!</span><span class="pl-smi">newState</span>.<span class="pl-en">setCell</span>(cell, player)){
      <span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Invalid cell index tested by AI.<span class="pl-pds">"</span></span>);
      <span class="pl-c1">process</span>.<span class="pl-en">exit</span>(<span class="pl-c1">1</span>);
    }
    <span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-smi">newState</span>.<span class="pl-en">getState</span>();
    <span class="pl-k">var</span> wins <span class="pl-k">=</span> <span class="pl-c1">0</span>;

    <span class="pl-k">for</span>(<span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">winConditions</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
      <span class="pl-k">if</span>(i <span class="pl-k">==</span> cell <span class="pl-k">||</span> state[i] <span class="pl-k">==</span> player <span class="pl-k">||</span> state[i] <span class="pl-k">==</span> <span class="pl-c1">0</span>){
        <span class="pl-k">for</span>(<span class="pl-k">var</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> winConditions[i].<span class="pl-c1">length</span>; j<span class="pl-k">++</span>){
          <span class="pl-k">var</span> firstCell <span class="pl-k">=</span> (winConditions[i][j][<span class="pl-c1">0</span>] <span class="pl-k">==</span> cell <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">0</span>]] <span class="pl-k">==</span> player <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">0</span>]] <span class="pl-k">==</span> <span class="pl-c1">0</span>);
          <span class="pl-k">var</span> secondCell <span class="pl-k">=</span> (winConditions[i][j][<span class="pl-c1">1</span>] <span class="pl-k">==</span> cell <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">1</span>]] <span class="pl-k">==</span> player <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">1</span>]] <span class="pl-k">==</span> <span class="pl-c1">0</span>);
          <span class="pl-k">var</span> isInCondition <span class="pl-k">=</span> (i <span class="pl-k">==</span> cell <span class="pl-k">||</span> winConditions[i][j][<span class="pl-c1">0</span>] <span class="pl-k">==</span> cell <span class="pl-k">||</span> winConditions[i][j][<span class="pl-c1">1</span>] <span class="pl-k">==</span> cell);

          <span class="pl-k">if</span>(firstCell <span class="pl-k">&amp;&amp;</span> secondCell <span class="pl-k">&amp;&amp;</span> isInCondition){
            wins<span class="pl-k">++</span>;

            <span class="pl-k">var</span> cellsTotal <span class="pl-k">=</span> state[i] <span class="pl-k">+</span> state[winConditions[i][j][<span class="pl-c1">0</span>]] <span class="pl-k">+</span> state[winConditions[i][j][<span class="pl-c1">1</span>]];
            <span class="pl-k">if</span>(cellsTotal <span class="pl-k">==</span> (player <span class="pl-k">*</span> <span class="pl-c1">2</span>)){
              wins<span class="pl-k">++</span>;

              <span class="pl-k">var</span> targetCell <span class="pl-k">=</span> (state[i] <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">?</span> i <span class="pl-k">:</span> (state[winConditions[i][j][<span class="pl-c1">0</span>]] <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">?</span> winConditions[i][j][<span class="pl-c1">0</span>] <span class="pl-k">:</span> winConditions[i][j][<span class="pl-c1">1</span>];
              wins <span class="pl-k">-=</span> <span class="pl-en">processOpponentState</span>(newState, targetCell);
            }
          }
        }
      }
    }

    <span class="pl-k">return</span> wins;
  }

  <span class="pl-k">function</span> <span class="pl-en">processOpponentState</span>(<span class="pl-smi">gameState</span>, <span class="pl-smi">cell</span>){
    <span class="pl-k">var</span> player <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-k">var</span> newState <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">clone</span>();
    <span class="pl-k">if</span>(<span class="pl-k">!</span><span class="pl-smi">newState</span>.<span class="pl-en">setCell</span>(cell, player)){
      <span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Invalid cell index tested by AI in opponent prediction.<span class="pl-pds">"</span></span>);
      <span class="pl-c1">process</span>.<span class="pl-en">exit</span>(<span class="pl-c1">1</span>);
    }

    <span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-smi">newState</span>.<span class="pl-en">getState</span>();
    <span class="pl-k">var</span> wins <span class="pl-k">=</span> <span class="pl-c1">0</span>;

    <span class="pl-k">for</span>(<span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">winConditions</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
      <span class="pl-k">if</span>(i <span class="pl-k">==</span> cell <span class="pl-k">||</span> state[i] <span class="pl-k">==</span> player <span class="pl-k">||</span> state[i] <span class="pl-k">==</span> <span class="pl-c1">0</span>){
        <span class="pl-k">for</span>(<span class="pl-k">var</span> j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> winConditions[i].<span class="pl-c1">length</span>; j<span class="pl-k">++</span>){
          <span class="pl-k">var</span> firstCell <span class="pl-k">=</span> (winConditions[i][j][<span class="pl-c1">0</span>] <span class="pl-k">==</span> cell <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">0</span>]] <span class="pl-k">==</span> player <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">0</span>]] <span class="pl-k">==</span> <span class="pl-c1">0</span>);
          <span class="pl-k">var</span> secondCell <span class="pl-k">=</span> (winConditions[i][j][<span class="pl-c1">1</span>] <span class="pl-k">==</span> cell <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">1</span>]] <span class="pl-k">==</span> player <span class="pl-k">||</span> state[winConditions[i][j][<span class="pl-c1">1</span>]] <span class="pl-k">==</span> <span class="pl-c1">0</span>);
          <span class="pl-k">var</span> isInCondition <span class="pl-k">=</span> (i <span class="pl-k">==</span> cell <span class="pl-k">||</span> winConditions[i][j][<span class="pl-c1">0</span>] <span class="pl-k">==</span> cell <span class="pl-k">||</span> winConditions[i][j][<span class="pl-c1">1</span>] <span class="pl-k">==</span> cell);
          <span class="pl-k">var</span> cellsTotal <span class="pl-k">=</span> state[i] <span class="pl-k">+</span> state[winConditions[i][j][<span class="pl-c1">0</span>]] <span class="pl-k">+</span> state[winConditions[i][j][<span class="pl-c1">1</span>]];

          <span class="pl-k">if</span>(firstCell <span class="pl-k">&amp;&amp;</span> secondCell <span class="pl-k">&amp;&amp;</span> isInCondition <span class="pl-k">&amp;&amp;</span> cellsTotal <span class="pl-k">==</span> (player <span class="pl-k">*</span> <span class="pl-c1">2</span>)){
            wins<span class="pl-k">++</span>;
          }
        }
      }
    }

    <span class="pl-k">return</span> wins;
  }

  <span class="pl-k">function</span> <span class="pl-en">hasImminentWin</span>(<span class="pl-smi">gameState</span>, <span class="pl-smi">cell</span>, <span class="pl-smi">player</span>){
    <span class="pl-k">var</span> newState <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">clone</span>();
    <span class="pl-k">if</span>(<span class="pl-k">!</span><span class="pl-smi">newState</span>.<span class="pl-en">setCell</span>(cell, player)){
      <span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">"</span>Invalid cell index tested by AI in opponent win pre-scan<span class="pl-pds">"</span></span>);
      <span class="pl-c1">process</span>.<span class="pl-en">exit</span>(<span class="pl-c1">1</span>);
    }

    <span class="pl-k">return</span> <span class="pl-smi">newState</span>.<span class="pl-en">hasWinner</span>();
  }

  <span class="pl-smi">ai</span>.<span class="pl-en">selectCell</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">gameState</span>){
    <span class="pl-k">var</span> state <span class="pl-k">=</span> <span class="pl-smi">gameState</span>.<span class="pl-en">getState</span>();
    <span class="pl-k">var</span> cells <span class="pl-k">=</span> {};
    <span class="pl-k">var</span> opponentWins <span class="pl-k">=</span> [];

    <span class="pl-k">var</span> index <span class="pl-k">=</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
    <span class="pl-k">var</span> indexes <span class="pl-k">=</span> [];
    <span class="pl-k">while</span>((index <span class="pl-k">=</span> <span class="pl-smi">state</span>.<span class="pl-c1">indexOf</span>(<span class="pl-c1">0</span>, index <span class="pl-k">+</span> <span class="pl-c1">1</span>)) <span class="pl-k">&gt;</span> <span class="pl-k">-</span><span class="pl-c1">1</span>){
      <span class="pl-k">if</span>(<span class="pl-en">hasImminentWin</span>(gameState, index, <span class="pl-c1">2</span>)){
        <span class="pl-k">return</span> index;
      }
      <span class="pl-k">if</span>(<span class="pl-en">hasImminentWin</span>(gameState, index, <span class="pl-c1">1</span>)){
        <span class="pl-smi">opponentWins</span>.<span class="pl-c1">push</span>(index);
      }
      cells[index] <span class="pl-k">=</span> <span class="pl-en">processGameState</span>(gameState, index);
      <span class="pl-smi">indexes</span>.<span class="pl-c1">push</span>(index);
    }

    <span class="pl-k">if</span>(<span class="pl-smi">opponentWins</span>.<span class="pl-c1">length</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>){
      <span class="pl-k">return</span> opponentWins[<span class="pl-c1">Math</span>.<span class="pl-c1">floor</span>(<span class="pl-c1">Math</span>.<span class="pl-c1">random</span>() <span class="pl-k">*</span> <span class="pl-smi">opponentWins</span>.<span class="pl-c1">length</span>)];
    }

    <span class="pl-k">var</span> cell <span class="pl-k">=</span> [indexes[<span class="pl-c1">0</span>]];
    <span class="pl-k">var</span> highest <span class="pl-k">=</span> cells[cell];
    <span class="pl-k">for</span>(<span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">1</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">indexes</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
      <span class="pl-k">if</span>(cells[indexes[i]] <span class="pl-k">&gt;</span> highest){
        cell <span class="pl-k">=</span> [indexes[i]];
        highest <span class="pl-k">=</span> cells[cell];
      }
      <span class="pl-k">else</span> <span class="pl-k">if</span>(cells[indexes[i]] <span class="pl-k">==</span> highest){
        <span class="pl-smi">cell</span>.<span class="pl-c1">push</span>(indexes[i]);
      }
    }

    <span class="pl-k">return</span> cell[<span class="pl-c1">Math</span>.<span class="pl-c1">floor</span>(<span class="pl-c1">Math</span>.<span class="pl-c1">random</span>() <span class="pl-k">*</span> <span class="pl-smi">cell</span>.<span class="pl-c1">length</span>)];
  }

  <span class="pl-k">return</span> ai;
});

<span class="pl-c1">module</span>.<span class="pl-smi">exports</span> <span class="pl-k">=</span> <span class="pl-c1">AI</span>;</pre></div>
<p><code>/CLI/index.js</code></p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-c1">CLI</span> <span class="pl-k">=</span> (<span class="pl-k">function</span>(<span class="pl-k">interface</span> <span class="pl-c"><span class="pl-c">/**</span> Readline.Interface *<span class="pl-c">*/</span></span>){
  <span class="pl-k">var</span> cli <span class="pl-k">=</span> {};
  <span class="pl-smi">cli</span>.<span class="pl-en">write</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">str</span>){
    <span class="pl-k">interface</span>.<span class="pl-c1">write</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span> <span class="pl-k">+</span> str <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
  };

  <span class="pl-smi">cli</span>.<span class="pl-en">prompt</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">question</span>){
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Promise</span>(<span class="pl-k">function</span>(<span class="pl-smi">resolve</span>, <span class="pl-smi">reject</span>){
      <span class="pl-k">interface</span>.<span class="pl-en">question</span>(question, <span class="pl-k">function</span>(<span class="pl-smi">answer</span>){
        <span class="pl-en">resolve</span>(answer);
      });
    });
  };

  <span class="pl-k">return</span> cli;
});

<span class="pl-c1">module</span>.<span class="pl-smi">exports</span> <span class="pl-k">=</span> <span class="pl-c1">CLI</span>;</pre></div>
<p><code>/GameState/index.js</code></p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> GameState <span class="pl-k">=</span> (<span class="pl-k">function</span>(<span class="pl-smi">state</span>){
  state <span class="pl-k">=</span> state <span class="pl-k">||</span> [<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">0</span>];
  <span class="pl-k">const</span> <span class="pl-c1">winConditions</span> <span class="pl-k">=</span> [
    [
      [<span class="pl-c1">1</span>,<span class="pl-c1">2</span>],  <span class="pl-c"><span class="pl-c">//</span>Top Row</span>
      [<span class="pl-c1">3</span>,<span class="pl-c1">6</span>],  <span class="pl-c"><span class="pl-c">//</span>Left Column</span>
      [<span class="pl-c1">4</span>,<span class="pl-c1">8</span>]   <span class="pl-c"><span class="pl-c">//</span>Right-Down Diagonal</span>
    ],
    [
      [<span class="pl-c1">4</span>,<span class="pl-c1">7</span>]   <span class="pl-c"><span class="pl-c">//</span>Center Column</span>
    ],
    [
      [<span class="pl-c1">5</span>,<span class="pl-c1">8</span>],  <span class="pl-c"><span class="pl-c">//</span>Right Column</span>
      [<span class="pl-c1">4</span>,<span class="pl-c1">6</span>]   <span class="pl-c"><span class="pl-c">//</span>Left-Down Diagonal</span>
    ],
    [
      [<span class="pl-c1">4</span>,<span class="pl-c1">5</span>]   <span class="pl-c"><span class="pl-c">//</span>Center Row</span>
    ],
    [],
    [],
    [
      [<span class="pl-c1">7</span>,<span class="pl-c1">8</span>]   <span class="pl-c"><span class="pl-c">//</span>Bottom Row</span>
    ]
  ];

  <span class="pl-k">var</span> gs <span class="pl-k">=</span> {};

  <span class="pl-smi">gs</span>.<span class="pl-en">hasEmptyCells</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-k">return</span> <span class="pl-smi">state</span>.<span class="pl-c1">indexOf</span>(<span class="pl-c1">0</span>) <span class="pl-k">&gt;</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
  }

  <span class="pl-smi">gs</span>.<span class="pl-en">hasWinner</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-k">var</span> i;
    <span class="pl-k">for</span>(i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">winConditions</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>){
      <span class="pl-k">var</span> token;
      <span class="pl-k">if</span>((token <span class="pl-k">=</span> state[i]) <span class="pl-k">!=</span> <span class="pl-c1">0</span>){
        <span class="pl-k">var</span> j;
        <span class="pl-k">for</span>(j <span class="pl-k">=</span> <span class="pl-c1">0</span>; j <span class="pl-k">&lt;</span> winConditions[i].<span class="pl-c1">length</span>; j<span class="pl-k">++</span>){
          <span class="pl-k">var</span> cells <span class="pl-k">=</span> winConditions[i][j];
          <span class="pl-k">if</span>(state[cells[<span class="pl-c1">0</span>]] <span class="pl-k">==</span> token <span class="pl-k">&amp;&amp;</span> state[cells[<span class="pl-c1">1</span>]] <span class="pl-k">==</span> token){
            <span class="pl-k">return</span> token;
          }
        }
      }
    }

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
  }

  <span class="pl-smi">gs</span>.<span class="pl-en">setCell</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">cell</span>, <span class="pl-smi">player</span>){
    <span class="pl-k">if</span>(state[cell] <span class="pl-k">==</span> <span class="pl-c1">0</span>){
      state[cell] <span class="pl-k">=</span> player;
      <span class="pl-k">return</span> <span class="pl-c1">true</span>;
    }
    <span class="pl-k">return</span> <span class="pl-c1">false</span>;
  }

  <span class="pl-smi">gs</span>.<span class="pl-en">getState</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-k">return</span> state;
  }

  <span class="pl-smi">gs</span>.<span class="pl-en">clone</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">GameState</span>(<span class="pl-smi">state</span>.<span class="pl-c1">slice</span>(<span class="pl-c1">0</span>)); <span class="pl-c"><span class="pl-c">//</span>Need to slice the array so it's not passing a reference to the parent state.</span>
  }

  <span class="pl-smi">gs</span>.<span class="pl-en">getWinConditions</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
    <span class="pl-k">return</span> winConditions;
  }

  <span class="pl-k">return</span> gs;
});

<span class="pl-c1">module</span>.<span class="pl-smi">exports</span> <span class="pl-k">=</span> GameState;</pre></div>


    </div>
  </body>
</html>
